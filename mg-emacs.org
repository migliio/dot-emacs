:PROPERTIES:
:ID:       d3909734-3c20-430c-b0c1-7246984a0111
:END:
#+TITLE: Emacs configuration
#+AUTHOR: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
#+macro: latest-export-date (eval (format-time-string "%Y-%m-%d, %A @ %I:%M %p"))
#+macro: word-count (eval (count-words (point-min) (point-max)))
#+macro: lines-count (eval (count-lines (point-min) (point-max)))
#+macro: file-creation-date (eval (file-attributes (f-this-file)))
#+options: toc:nil
*This file was revised and exported on {{{latest-export-date}}}, with a word count of {{{word-count}}} and a line count of {{{lines-count}}}.*

This is a literate GNU Emacs configuration file. It doesn't serve as an actual configuration file, but as a commentary on the configuration itself and generates all the source files used to modify and tweak the Emacs text editor. This file is therefore verbose, with prose describing each and every piece of code listed in it. This serves as a future reference for me to have a clue on why some design choices have been preferred with respect to others.
As of {{{latest-export-date}}}, the structure of this directory is organized as follows:
#+begin_src bash :wrap example :exports results
  tree -aF -L 2 -I 'straight|edts|elpa|.git|eln-cache|.headers|.gitignore|.gitmodules|.snippets|.locks|auto-save-list|url'
#+end_src

#+RESULTS:
#+begin_example
| ./  |                    |                                |       |
| ├── | init.el            |                                |       |
| ├── | LICENSE.md         |                                |       |
| ├── | mg-custom-modules/ |                                |       |
| │   | ├──                | mg-bib.el                      |       |
| │   | ├──                | mg-citar-denote.el             |       |
| │   | ├──                | mg-defaults-extensions.el      |       |
| │   | ├──                | mg-denote.el                   |       |
| │   | ├──                | mg-emacs.el                    |       |
| │   | ├──                | mg-kernel.el                   |       |
| │   | ├──                | mg-macos.el                    |       |
| │   | ├──                | mg-modeline.el                 |       |
| │   | ├──                | mg-notmuch.el                  |       |
| │   | ├──                | mg-org.el                      |       |
| │   | ├──                | mg-org-gtd.el                  |       |
| │   | ├──                | mg-personal.el                 |       |
| │   | ├──                | mg-pkm-utils.el                |       |
| │   | └──                | mg-utils.el                    |       |
| ├── | mg-emacs-modules/  |                                |       |
| │   | ├──                | mg-emacs-ai.el                 |       |
| │   | ├──                | mg-emacs-bib.el                |       |
| │   | ├──                | mg-emacs-browsing.el           |       |
| │   | ├──                | mg-emacs-buffers-completion.el |       |
| │   | ├──                | mg-emacs-buffers.el            |       |
| │   | ├──                | mg-emacs-defaults.el           |       |
| │   | ├──                | mg-emacs-denote.el             |       |
| │   | ├──                | mg-emacs-files.el              |       |
| │   | ├──                | mg-emacs-flashcards.el         |       |
| │   | ├──                | mg-emacs-git.el                |       |
| │   | ├──                | mg-emacs-languages.el          |       |
| │   | ├──                | mg-emacs-layouts.el            |       |
| │   | ├──                | mg-emacs-ledger.el             |       |
| │   | ├──                | mg-emacs-markup.el             |       |
| │   | ├──                | mg-emacs-notmuch.el            |       |
| │   | ├──                | mg-emacs-org.el                |       |
| │   | ├──                | mg-emacs-package-managers.el   |       |
| │   | ├──                | mg-emacs-programming.el        |       |
| │   | └──                | mg-emacs-themes.el             |       |
| └── | mg-emacs.org       |                                |       |
|     |                    |                                |       |
| 3   | directories,       | 36                             | files |
#+end_example

In general, this configuration is organized using modules, each designed to introduce a set of packages for a specific purpose. The objective is to minimize the number of packages introduced within a single module to ensure a clear separation of concerns. Introducing too many packages at once reduces clarity.

I started using GNU Emacs at ~ [2020-04-30 Thu], and I've been tweaking and extensively using it since then. This will become quite evident when you go through this configuration file. Since I even used it as a window manager for X (until I switched to Wayland), it's not an exaggeration to say that I've been heavily working with Emacs in the last ~ 5 years. Each section of this document serves as introduction to a single module, and subsections focus on different core packages/configurations inside that module. Hope this becomes pretty self-explanatory throughout this artifact.

Therefore, the structure of this configuration file can be summarized as follows:
- The ~init.el~ source file :: This is the main point of entry for the entire configuration, and it is the source file read when Emacs is starting up. This file then loads the Emacs modules, which enable packages and functionalities for the editor;
- The ~mg-emacs-modules~ :: These are modules that loads Emacs packages, without introducing any custom functionalities. The only tweaking activity done by those source files is simple package configuration. Those source files may load custom libraries (see next entry);
- The ~mg-custom-modules~ :: These are custom modules written by me. Their goal is to introduce new functionalities, extend packages and tweak the Emacs editor. In other words, while ~mg-emacs-modules~ only "load" the packages and tweak their variables and options, ~mg-custom-modules~ modify and extend the behavior of both Emacs and its loaded packages.


#+toc: headlines 5

* The ~init.el~ source file

This file deals with the early initialization of the GNU Emacs editor. It is, indeed, the main source file that is loaded by Emacs when performing the startup. What it does is to simply load all the other modules. There is a ~require~ statement for each module to load into the editor. There are several conditions to discriminate whether a module should be loaded based on which system Emacs is executing.

#+begin_src emacs-lisp :tangle "init.el"
  (require 'server)
  (unless (server-running-p)
    (server-start))

  (add-to-list 'load-path (expand-file-name
  			 "~/.emacs.d/mg-emacs-modules/"))
  (add-to-list 'load-path (expand-file-name
  			 "~/.emacs.d/mg-custom-modules/"))

  (require 'mg-emacs-package-managers)
  (require 'mg-utils)
  (require 'mg-emacs-defaults)
  (require 'mg-emacs-themes)
  (require 'mg-emacs-buffers-completion)
  (require 'mg-emacs-files)
  (require 'mg-emacs-buffers)
  (when (not (mg-connected-via-ssh-p))
    (progn
      (require 'mg-emacs-layouts)
      (require 'mg-emacs-org)
      (require 'mg-emacs-denote)
      (require 'mg-emacs-bib)
      (require 'mg-emacs-ledger)
      (require 'mg-emacs-flashcards)
      (require 'mg-emacs-notmuch)
      (require 'mg-emacs-browsing)
      (require 'mg-emacs-ai)))
  (require 'mg-emacs-markup)
  (require 'mg-emacs-languages)
  (require 'mg-emacs-git)
  (require 'mg-emacs-programming)
#+end_src

* The ~mg-emacs-modules~
** The ~mg-emacs-package-managers.el~ module

The idea of this module is to initialize the package managers that I use. In my system, ~use-package~ and ~straight.el~ are used in conjunction, and I think that the flexibility they provide is simply amazing. I started using ~straight.el~ from [2024-01-30 Tue] and never regret that decision.

Thus, this module provides the bootstrapping phase for both the two package managers. From Emacs 29, ~use-package~ doesn't need to be installed anymore, it is built into Emacs. The code below just adds ~melpa~ as the list of sources and do ~package-initialize~. Just a required clarification: ~use-package~ is not a package manager, it is just a set of macros. For the sake of clarity, I called this module ~mg-emacs-package-managers.el~, although both ~use-package~ and ~straight.el~ are not strictly "package managers". In general, I don't care, and that's why I'll use this slight abuse of notation from now on.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-package-managers.el" :mkdirp yes
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (unless package--initialized (package-initialize))
#+end_src

Then, the module handles the bootstrapping phase of ~straight.el~ as well. The code below downloads the bootstrap file for ~straight.el~, in case it hasn't been already downloaded, and executes that file using ~load~. The more I use this editor extensively, the more it happens that I'd like to have features on "develop" branches for some packages, and having a declarative way to pull the package directly from its repository, specifying which branch we're interested in (or even which commit), feels very appealing.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-package-managers.el"

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
  	"straight/repos/straight.el/bootstrap.el"
  	(or (bound-and-true-p straight-base-dir)
  	    user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
  	(url-retrieve-synchronously
  	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
  	 'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (provide 'mg-emacs-package-managers)
#+end_src

** The ~mg-emacs-defaults.el~ module

This module contains the initialization of some useful defaults that I use within Emacs.

When going through the module, you'll see that there is a condition checking if I'm running on MacOS, and, if that's the case, it loads a custom library, called ~mg-macos.el~ (see [[id:93f60f28-3019-4010-9012-f7897dc3b873][The ~mg-macos~ library]]). In fact, mainly when on laptops for work, I use Emacs also on MacOS and, thus, I needed some code to make the system work flawlessly on that operating system.

The code below is used to disable some boring modes like ~scroll-bar-mode~ and ~tool-bar-mode~, menus and the like, and to enable others that I find particularly useful, such as ~visual-mode~ and ~show-paren-mode~. Moreover, I have the definition of some defaults for locales and encoding.
Historically, this module enclosed a bunch of other customizations for variables related to specific modes (e.g., ~org-mode~, ~c-mode~). I found it confusing and even wrong in some cases. That's why now the idea is to tweak emacs-specific variables *only*.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-defaults.el"
  (use-package emacs
    :bind (("M-n" . forward-paragraph)
  	 ("M-p" . backward-paragraph)
  	 ("C-c u r s" . replace-string)
  	 ("C-c u r q" . query-replace-regexp)
  	 ("C-c u r r" . query-replace)
  	 ("C-c u r c" . comment-region)
  	 ("C-c u r u" . uncomment-region)
  	 ("C-c u r i" . indent-region)
  	 ("C-c u r a r" . align-regexp)
  	 ("C-c u r a e" . align-entire)
  	 ("C-c u c w" . whitespace-mode)
  	 ("C-c u m" . compile)
  	 ("C-c u x" . async-shell-command)
  	 ("C-c u w f" . toggle-frame-fullscreen)
  	 ("C-c u w m" . toggle-frame-maximized)
  	 ("C-x C-n" . next-buffer)
  	 ("C-x a a" . async-shell-command)
  	 ("C-x C-p" . previous-buffer))
    :init
    (global-set-key (kbd "C-x C-n") nil)
    (global-set-key (kbd "C-x C-p") nil)
    (defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
    (defconst mg-dot-private-file "~/Repositories/knock-files-private")
    (defconst mg-emacs-root "~/.emacs.d")
    (defconst mg-sendmail-bin "/usr/bin/msmtp")
    (setq inhibit-startup-screen t
  	completion-cycle-threshold 3
  	tab-always-indent 'complete
  	create-lockfiles nil
  	user-emacs-directory (expand-file-name "~/.cache/emacs/")
  	bookmarks-file (expand-file-name ".bookmarks/bookmarks" mg-emacs-root)
  	url-history-file (expand-file-name "url/history" user-emacs-directory)
  	custom-file (if (boundp 'server-socket-dir)
  			(expand-file-name "custom.el" server-socket-dir)
  		      (expand-file-name (format "emacs-custom-%s.el" (user-uid)) temporary-file-directory))
  	backup-by-copying t
  	delete-old-versions t
  	kept-new-versions 6
  	kept-old-versions 2
  	message-send-mail-function 'message-send-mail-with-sendmail
  	sendmail-program mg-sendmail-bin
  	version-control t
  	auto-save-list-file-prefix emacs-tmp-dir
  	auto-save-file-name-transforms `((".*" ,emacs-tmp-dir t))
  	backup-directory-alist `((".*" . ,emacs-tmp-dir)))
    
    (setq-default frame-title-format '("%b")
  		ring-bell-function 'ignore
  		tab-width 8
  		frame-resize-pixelwise t
  		linum-format "%4d "
  		use-short-answers t
  		electric-indent-mode nil
  		make-backup-files nil
  		global-auto-revert-mode t
  		confirm-kill-processes nil
  		process-connection-type nil
  		org-src-fontify-natively t
  		;; warning-minimum-level :emergency
  		set-language-environment "UTF-8"
  		system-time-locale "C"
  		native-comp-async-report-warnings-errors nil)
    (load custom-file t)
    (add-hook 'window-setup-hook 'toggle-frame-maximized t)
    (add-to-list 'yank-excluded-properties 'face)
    (if (display-graphic-p)
        (dolist (mode
  	       '(tool-bar-mode
  		 scroll-bar-mode
  		 menu-bar-mode
  		 tooltip-mode
  		 blink-cursor-mode))
  	(funcall mode 0)))
    (dolist (mode
  	   '(global-visual-line-mode
  	     show-paren-mode))
      (funcall mode 1)))

  (use-package mg-macos
    :if (eq system-type 'darwin)
    :ensure nil
    :config
    (mg-macos-support-enable))

  (use-package mg-emacs
    :after (mg-utils)
    :bind (("C-c p s" . mg-take-screenshot)
  	 ("C-c u f" . mg-add-current-file-name-to-killring)
  	 ("C-c u t" . mg-insert-today-timestamp-formatted)))

  (use-package mg-defaults-extensions
    :ensure nil
    :config
    (add-hook 'prog-mode-hook
  	    #'mg-line-numbers-highlight-line-mode))
#+end_src

The ~mg-line-numbers-highlight-line-mode~ minor mode is only used when the ~prog-mode~ major mode is enabled. There is no reason for my specific use cases to have line numbers outside of coding. However, I use this feature quite extensively when programming. In text editors like Emacs, relative line numbers add a 10x speed in the way you insert/remove/modify text.

Next, I enable ~which-key~ to remind me what keybinds to use to perform some actions. This is convenient because I often forget some keybindings that are not constantly part of my workflow. The idea of which-key is to pop a small list in the minibuffer showing pairs of ~(<next_key>, <emacs-command>)~ to facilitate the choice of pressing the next key in the sequence of keys for launching a certain Emacs command.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-defaults.el"
  (use-package which-key
    :straight t
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3))
#+end_src

Starting from [2024-04-14 Sun], I decided to implement my own mode-line to keep things simple and under control. I thought there was so much wasted space in the default one, and most of the information were not completely clear. Now, I can immediately see whether I'm editing a local or remote file (i.e., by looking at either ~"@"~ or ~"^"~ characters on the left-hand side of the modeline), which derived mode I'm in, and whether the current buffer is in read-only mode. Those are all information already specified by the default modeline, but their arrangement and syntax was unclear to me. The below snippet flows into the ~mg-custom-modeline.el~ module.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-defaults.el"
  (use-package mg-modeline
    :ensure nil)

  (provide 'mg-emacs-defaults)
#+end_src

** The ~mg-emacs-themes.el~ module

I typically favor simple and highly legible themes. I often switch between themes, and the process of finding one that truly suits me is ongoing. However, I generally rely on two different configurations, depending on the system I'm using (e.g., Linux vs. Mac). I prefer dark themes over light ones, and I enable a night shift with warmer colors settings across the entire day. I find that warm light is more comfortable for my eyes. The theme I am most attached to is [[https://github.com/bbatsov/zenburn-emacs][Zenburn]], a color scheme with a very low "distance" between its colours, which I find aesthetically pleasing and comfortable for my eyes.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-themes.el"
  (defun mg-init-macos-theme ()
    "Enable the theme environment of choice for darwin."
    (load-theme 'modus-vivendi t)
    (set-frame-font "DejaVu Sans Mono 18" nil t))

  (defun mg-init-cli-theme ()
    "Enable the theme environment of choice when from CLI."
    (load-theme 'modus-vivendi)
    (custom-set-faces '(mode-line ((t (:background "grey75" :foreground "black"
  						 :box (:line-width -1 :style released-button)))))
  		    '(mode-line-inactive ((t (:background "grey60" :foreground "black"
  							  :box (:line-width -1 :style released-button))))))
    (menu-bar-mode -1))

  (defun mg-init-linux-theme ()
    "Enable the theme enviroment of choice for linux."
    (load-theme 'modus-vivendi t)
    (set-frame-font "DejaVu Sans Mono 14" nil t))

  (if (display-graphic-p)
      (if (equal system-type 'darwin)
    	(mg-init-macos-theme)
        (mg-init-linux-theme))
    (mg-init-cli-theme))
  (set-fringe-mode 0)
#+end_src

The only other feature that needs some clarification for the above code is the conditional statement on the ~display-graphic-p~. When not on the GUI version of Emacs (i.e., from CLI), I prefer not to select any theme and just stick with the one used in the terminal emulator. I find this way to go way less confusing, and surely lowers cognitive overhead for me.
The following piece of code introduces ~hide-mode-line~ mode, which is used in a custom function of mine to enable PDF presentation mode (not technically an Emacs mode, rather a custom layout).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-themes.el"
  (use-package hide-mode-line
    :straight t)

  (provide 'mg-emacs-themes)
#+end_src

** The ~mg-emacs-layouts.el~ module
:PROPERTIES:
:ID:       3B58B914-77A7-4942-A229-1A639C6B9287
:END:

In this module I enable some other packages I use to visually customize buffers and text within Emacs. For instance, I use ~olivetti~ and ~logos~ in conjunction for conveniently display text to avoid distractions. This comes into play when I need to write huge wall of texts without switching back and forth to code listings (moving from a full-width piece of code to the ~olivetti-logos~ layout is indeed confusing to me, and raises cognitive overload).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-layouts.el"
  (use-package olivetti
    :straight t)

  (use-package logos
    :bind (("C-c p f" . logos-focus-mode))
    :straight t
    :custom
    (logos-outlines-are-pages t)
    :config
    (setq-default logos-hide-cursor nil
  		logos-hide-mode-line t
  		logos-hide-header-line t
  		logos-hide-buffer-boundaries t
  		logos-hide-fringe t
  		logos-variable-pitch nil
  		logos-buffer-read-only nil
  		logos-scroll-lock nil
  		logos-olivetti t)
    (let ((map global-map))
      (define-key map [remap narrow-to-region] #'logos-narrow-dwim)
      (define-key map [remap forward-page] #'logos-forward-page-dwim)
      (define-key map [remap backward-page] #'logos-backward-page-dwim)))

  (provide 'mg-emacs-layouts)
#+end_src

** The ~mg-emacs-buffers-completion.el~ module

Buffer management and buffer/minibuffer completion are unified in this configuration. I switch and manage (e.g., kill) buffers mainly through ~consult-ibuffer~ (to be described later), but sometimes I find useful to have a grouping and management that I find similar to ~dired~. That's why I use ~ibuffer~, which provides these features out-of-the-box, and it is part of Emacs since version 22.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-buffers-completion.el"
  (use-package ibuffer
    :ensure nil
    :bind
    (("C-x C-b" . ibuffer))
    :config
    (setq ibuffer-expert t)
    (setq ibuffer-saved-filter-groups
  	(quote (("default"
  		 ("org" (mode . org-mode))
  		 ("dired" (mode . dired-mode))
  		 ("magit" (name . "^magit"))
  		 ("c-src" (mode . c-mode))
  		 ("python-src" (mode . python-mode))
  		 ("virt-manager" (name . "^Virt-manager"))
  		 ("brave" (name . "^Brave"))
  		 ("jabber" (name . "^*-jabber"))
  		 ("vterminal" (name . "^\\*vterminal"))
  		 ("emacs" (or
  			   (name . "^\\*scratch\\*$")
  			   (name . "^\\*Messages\\*$")))
  		 ))))
    (setq ibuffer-default-sorting-mode 'alphabetic)
    (add-hook 'ibuffer-mode-hook
  	    (lambda ()
  	      (ibuffer-switch-to-saved-filter-groups "default")
  	      )))
#+end_src

For completion in both standard buffers and minibuffers, I employ a popular stack of packages: Vertico, Orderless, Marginalia, Consult, and Corfu. I particularly appreciate the modular nature of this setup. For instance, if a user doesn't favor Consult, they can easily retain the default completion system while still benefiting from the other packages. Personally, I find these packages highly effective in their default configurations, so I've rarely felt the need to customize them extensively.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-buffers-completion.el"

  (use-package vertico
    :straight t
    :config
    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
    (vertico-mode))

  (use-package marginalia
    :straight t
    :config
    (marginalia-mode))

  (use-package savehist
    :straight t
    :config
    (savehist-mode))

  (use-package orderless
    :straight t
    :custom
    (completion-styles '(orderless basic)))

  (use-package consult
    :straight t
    :bind (
  	 ("C-c M-x" . consult-mode-command)
  	 ("C-c h" . consult-history)
  	 ("C-c k" . consult-kmacro)
  	 ("C-c M-m" . consult-man)
  	 ("C-c i" . consult-info)
  	 ([remap Info-search] . consult-info)

  	 ("C-x b" . consult-buffer)
  	 ("C-x r b" . consult-bookmark)
  	 ("C-x p b" . consult-project-buffer)

  	 ("M-#" . consult-register-load)
  	 ("M-'" . consult-register-store)
  	 ("C-M-#" . consult-register)

  	 ("M-y" . consult-yank-pop)

  	 ("M-g e" . consult-compile-error)
  	 ("M-g f" . consult-flymake)
  	 ("M-g g" . consult-goto-line)
  	 ("M-g M-g" . consult-goto-line)
  	 ("M-g o" . consult-outline)
  	 ("M-g m" . consult-mark)
  	 ("M-g k" . consult-global-mark)
  	 ("M-g i" . consult-imenu)
  	 ("M-g I" . consult-imenu-multi)

  	 ("M-s d" . consult-find)
  	 ("M-s c" . consult-locate)
  	 ("M-s g" . consult-grep)
  	 ("M-s G" . consult-git-grep)
  	 ("M-s r" . consult-ripgrep)
  	 ("M-s l" . consult-line)
  	 ("M-s L" . consult-line-multi)
  	 ("M-s k" . consult-keep-lines)
  	 ("M-s u" . consult-focus-lines)

  	 ("M-s e" . consult-isearch-history)
  	 :map isearch-mode-map
  	 ("M-e" . consult-isearch-history)
  	 ("M-s e" . consult-isearch-history)
  	 ("M-s l" . consult-line)
  	 ("M-s L" . consult-line-multi)

  	 :map minibuffer-local-map
  	 ("M-s" . consult-history)
  	 ("M-r" . consult-history))
    :hook (completion-list-mode . consult-preview-at-point-mode)
    :init
    (setq xref-show-xrefs-function #'consult-xref
  	xref-show-definitions-function #'consult-xref)
    :config
    (consult-customize consult-buffer
  		     :preview-key "M-.")
    (setq consult-narrow-key ">"))

  (use-package corfu
    :straight (corfu :type git :host github :repo "minad/corfu" :commit "24dccafeea114b1aec7118f2a8405b46aa0051e0")
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    :config
    (global-corfu-mode)
    (corfu-popupinfo-mode))

  (provide 'mg-emacs-buffers-completion)
#+end_src

** The ~mg-emacs-files.el~ module

This module deals with file management. It includes packages to list, manage and open files (and some specific file types).

The ~dired~ file manager is likely one of the most useful and game changing features provided by the Emacs editor. Files, through their listing - e.g., as output of the ~ls~ command -, are managed as they were written into a standard Emacs buffer. This means that every buffer convention still suffices when managing files. I usually omit dot files when listing with ~dired~ (when needed I can always make them appear again by disabling ~dired-omit-mode~).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-files.el"
  (use-package dired
    :ensure nil
    :custom
    (ls-lisp-use-insert-directory-program nil)
    (ls-lisp-dirs-first t)
    (default-directory "~/"))

  (use-package dired-x
    :ensure nil
    :custom
    (dired-omit-files "^\\...+$")
    (dired-dwim-target t)
    (delete-by-moving-to-trash t)
    (dired-omit-files "^\\.[^.].+$")
    :init
    (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1))))
#+end_src

There are cases when I need to open a file with an external program (e.g., video files with ~mpv~). For this use-case, there is a useful package called ~openwith~ that let us associate file extensions with external programs to open them.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-files.el"
  (use-package openwith
    :straight t
    :config
    (setq openwith-associations '(
  				("\\.mp4\\'" "mpv" (file))
  				("\\.webm\\'" "mpv" (file))
  				("\\.mkv\\'" "mpv" (file))
  				("\\.m4a\\'" "mpv --force-window" (file))
  				("\\.mov\\'" "mpv" (file))
  				("\\.ppt\\'" "libreoffice" (file))
  				("\\.pptx\\'" "libreoffice" (file))
  				("\\.doc\\'" "libreoffice" (file))
  				("\\.docx\\'" "libreoffice" (file))
  				))
    (openwith-mode t))
#+end_src

When dealing with PDFs, I leverage upon the ~pdf-tools~ suite, which does a pretty good job when it comes to view and annotate PDFs. There are better PDFs viewers out there (some of them have features that could really benefit my use-cases - e.g., [[https://sioyek.info/][Sioyek]]), but my strict requirement is to have one that lies into Emacs and is perfectly integrated with other Emacs packages (e.g., ~org-mode~, ~denote~, ~citar-denote~). That's why I'm using it.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-files.el"
  (use-package pdf-tools
    :straight t
    :config
    (add-hook 'pdf-view-mode-hook #'pdf-links-minor-mode)
    (define-key pdf-view-mode-map (kbd "f") #'pdf-links-isearch-link)
    (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-tools-install))
    (add-hook 'pdf-view-mode-hook
  	    (lambda () (setq header-line-format nil))))

  (provide 'mg-emacs-files)
#+end_src

** The ~mg-emacs-buffers.el~ module

This module handles various buffer editing packages. The concept of buffer is key in Emacs, it is like a sheet of paper in a notebook. Therefore, having packages that, for instance, allow us to move faster in a buffer, or efficiently undo a recent change, I think is of a great value.

The ~vundo~ package is my way to go when it comes to undo changes. I was using ~undo-tree~ before, and I still think it is a valid alternative to what I'm using now. However, I really enjoy ~vundo~'s simplicity and low visual overhead. However, on [2024-10-29 Tue 15:51] I decided to go back to ~undo-tree~ because ~vundo~ is buggy: sometimes I get weird errors when going substantially back in time with the changes, and I also got some ~"No possible route"~ bugs several times.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-buffers.el"
  (use-package undo-tree
    :straight t
    :init
    (global-undo-tree-mode)
    :custom
    (undo-tree-auto-save-history nil))
#+end_src

The ~mg-emacs-buffers~ module also introduces the [[https://github.com/migliio/buffier][buffier]] package, which is a project I created and maintain since [2025-01-11 Sat]. This package provides a streamlined way to open mode-rich temporary buffers and then search and open them. For now, the package is not available on MELPA.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-buffers.el"
  (use-package buffier
    :straight (buffier :type git :host github :repo "migliio/buffier" :branch "master")
    :bind (("C-c u b w" . buffier-new-buffer)
  	 ("C-c u b l" . buffier-buffers)))
#+end_src

My typing skills improved consistently in these years of Emacs usage. Thus, I needed a way to also move the cursor faster in the buffers. That's why I started using ~avy~, whose functionality could be a bit cumbersome at first, but after one gets used to it, is a 10x improvement in speed.
I find convenient to use the ~C-c ;~ and ~C-c ,~ keybindings (they are easily accessible), but they are reserved to ~org~. Hence, ~avy~ is loaded after ~org~ and the two keybindings are first removed from the ~org-mode~ keymap, and then reassigned to the main ~avy~ commands.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-buffers.el"
  (use-package avy
    :straight t
    :after org
    :init
    (eval-after-load 'org
      (progn
        (define-key org-mode-map (kbd "C-c ,") nil)
        (define-key org-mode-map (kbd "C-c ;") nil)))
    :bind
    (("C-c ;" . avy-goto-line)
     ("C-c ," . avy-goto-char)))

  (provide 'mg-emacs-buffers)
#+end_src

** The ~mg-emacs-markup.el~ module

This module loads some packages to handle markup languages as ~outline~ (which is Emacs specific) and Markdown. Although I do not use it extensively, I find ~outline-mode~ pretty useful to divide Emacs Lisp code into outlines (through comments starting with ~;;;~) to easily navigate throughout the file. I use Markdown to mainly write stuff to be later sent as Slack messages: I open a temporary buffer, toggle ~markdown-mode~, write the text with formatting and copy-paste it into Slack.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-markup.el"
  (use-package outline
    :ensure nil
    :bind
    ("C-c u c o" . outline-minor-mode)
    :custom
    (outline-minor-mode-highlight nil)
    (outline-minor-mode-cycle t)
    (outline-minor-mode-use-buttons nil)
    (outline-minor-mode-use-margins nil))

  (use-package markdown-mode
    :straight t
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))

  (provide 'mg-emacs-markup)
#+end_src

** The ~mg-emacs-org.el~ module
:PROPERTIES:
:ID:       6f7d6bb3-7e70-4a0b-ae3f-54b55086c35d
:END:

If I would be ever asked about the single most life changing Emacs package that I use, that would surely be ~org~. To its core, ~org-mode~ is just an Emacs major mode to edit files written according to a markup language (called, indeed, Org). As Emacs is just a Lisp interpreter at its core, but with many other implications coming from this, ~org-mode~ has a huge amount of useful, simple and effective features that I use every single day of my life. I use ~org-mode~ to take notes (in conjunction with ~denote~ - see [[id:64ce0bed-fefc-4603-91ef-24b4fd102795][The ~mg-emacs-denote.el~ module]]), manage appointments, handle todos, create flashcards (in conjunction to ~anki-editor~ - see [[id:93af5e84-4396-4994-9804-3edc69d8a070][The ~mg-emacs-flashcards.el~ module]]), store contact information, do literate programming, organize projects, manage expenses (in conjunction with ~ledger~ - see [[id:5fb29d20-1803-4301-80ff-d05d53397166][The ~mg-emacs-ledger.el~ module]]), and many others. It would be unrealistic to list all the needs I satisfy because of ~org-mode~'s existence.

Anyway, the important aspects of my ~org-mode~ configuration can be summarized with some key points. I use ~org-capture~ a lot, so my workflow revolves around writing code or notes, have some idea and trigger ~org-capture~ to write a reminder (or a TODO entry) to be later processed. Events, meetings, calls and the like are all tracked down by means of a ~org-capture~ template to write an entry in some ~org-agenda~ file. Thus, another key aspect of my ~org-mode~ workflow is to heavily used the agenda, tweaked to have a comprehensive view of what matter the most for me:
- Today's time grid, i.e., what is today's situation like? Did I have some meetings scheduled, or some deep work sessions either?
- What task am I working on? What is the next task to be handled? These two comes from a variation of the GTD system I implemented myself;
- What are the upcoming deadlines for the month?
- What is the state of my inbox? What are those tasks/reminders I captured but not clarified yet? Still some GTD-like feature that I adapted to my use-cases;
- What have I accomplished today?
- How is next week going to be like?


Those questions are all answered by just looking at the agenda, fired up with just a simple keystroke. That's how effective ~org-mode~ is to me. The other huge use-case for ~org-mode~ is note-taking, which I'll be addressing in the ~denote~ section (see [[id:64ce0bed-fefc-4603-91ef-24b4fd102795][The ~mg-emacs-denote.el~ module]]). Alongside ~org~, I use several packages which are directly related to the latter. For instance, I find ~org-transclusion~ pretty neat when it comes to artifact writing (e.g., papers, blog posts) and I use it for that matter. The ~org~ package is the backbone for my whole note-taking system.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-org.el"
  (use-package mg-org
    :after (org)
    :ensure nil
    :bind (("C-c o c d" . mg-org-compute-deep-work-minutes)
  	 ("C-c o b" . mg-org-block-time)
  	 ("C-c o m" . mg-org-compile-tex-from-assets)))

  (use-package org
    :straight t
    :init
    (require 'mg-bib)
    :bind (("C-c a" . org-agenda)
  	 ("C-c C-;" . org-insert-structure-template)
  	 ("C-c c" . org-capture)
  	 ("C-c C-z" . org-add-note)
  	 ("C-c o p" . org-do-promote)
  	 ("C-c o d" . org-do-demote)
  	 ("C-c p o r" . org-clock-report)
  	 ("C-c l" . org-store-link))
    :init
    (require 'mg-bib)
    :custom
    (org-bookmark-names-plist nil)
    (org-src-tab-acts-natively t)
    (org-M-RET-may-split-line '((default . nil)))
    (org-agenda-files (list mg-work-projects-file mg-personal-projects-file mg-agenda-file mg-inbox-file mg-capture-notes-file))
    (org-archive-location "~/Vault/pkm/.archive/archive.org::* From %s")
    (org-export-backends '(beamer html latex icalendar ascii))
    (org-structure-template-alist
     '(("a" . "export ascii")
       ("c" . "center")
       ("C" . "comment")
       ("e" . "example")
       ("E" . "export")
       ("h" . "export html")
       ("l" . "export latex")
       ("q" . "quote")
       ("s" . "src")
       ("L" . "src emacs-lisp")
       ("t" . "src emacs-lisp :tangle FILENAME")
       ("T" . "src emacs-lisp :tangle FILENAME :mkdirp yes")))
    (org-startup-folded nil)
    (org-log-into-drawer t)
    (org-export-with-drawers nil)
    (org-clock-clocked-in-display 'mode-line)
    (org-clock-idle-time nil)
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "DOING(p@/!)" "HOLD(h)" "|" "DONE(d)")))
    (org-stuck-projects '("+project/" ("NEXT" "TODO") ("course") "\\(Details\\|Artifacts\\|Resources\\)\\>"))
    (org-log-done 'time)
    (org-agenda-hide-tags-regexp ".")
    (org-id-link-to-org-use-id nil)
    (org-refile-use-outline-path 'file)
    (org-outline-path-complete-in-steps nil)
    (org-clock-sources '(agenda))
    (org-capture-templates
     '(("b" "Bibliography")
       ("bp" "Paper/book" entry (file mg-references-file)
        #'mg-bib-denote-org-capture-paper-biblio
        :kill-buffer t
        :jump-to-captured nil)
       ("bi" "ISBN" entry (file mg-references-file)
        #'mg-bib-denote-org-capture-book-isbn-biblio
        :kill-buffer t
        :jump-to-captured nil)
       ("bw" "Website" entry (file mg-references-file)
        #'mg-bib-denote-org-capture-website-biblio
        :kill-buffer t
        :jump-to-captured nil)
       ("i" "Inbox")
       ("it" "Todo entry" entry (file mg-inbox-file)
  	"* TODO %? :inbox:\n:PROPERTIES:\n:CATEGORY: INBOX\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:")
       ("im" "Mail entry" entry (file mg-inbox-file)
  	"* TODO Process \"%a\" %? :inbox:\n:PROPERTIES:\n:CATEGORY: INBOX\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:")
       ("in" "Notes entry" entry (file mg-capture-notes-file)
  	"* %U (%a) :inbox:\n:PROPERTIES:\n:CATEGORY: INBOX\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:")
       ("a" "Agenda")
       ("am" "Meeting entry" entry (file+headline mg-agenda-file "Future")
  	"* Meeting with %? :meeting:\n:PROPERTIES:\n:LOCATION:\n:CATEGORY: %^{Category}\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:\n%^T\n")
       ("as" "Schedule entry" entry (file+headline mg-agenda-file "Schedule")
  	"* TODO %? :schedule:\n:PROPERTIES:\n:CATEGORY: %^{Category}\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:\n%^T\n- Project :: \n- Description :: \n- Outcome :: \n")
       ("ae" "Event entry" entry (file+headline mg-agenda-file "Future")
  	"* %? :event:\n:PROPERTIES:\n:LOCATION:\n:CATEGORY:\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:\n%^T\n")
       ("ac" "Call entry" entry (file+headline mg-agenda-file "Future")
  	"* Call with %? :call:\n:PROPERTIES:\n:CATEGORY:\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:\n%^T\n")
       ("ap" "Coaching session with Prot entry" entry (file+headline mg-agenda-file "[[denote:20240510T212918][Protesilaos Stavrou]]")
  	"* Coaching session :@home:@personal:\n:PROPERTIES:\n:LOCATION: @home\n:CATEGORY: PROT\n:LINK:\n:END:\n:LOGBOOK:\n- Entry inserted on %U \\\\\n:END:\n%^T\n** Topics to discuss\n** Questions from last time\n")
       ("r" "Resources")
       ("ra" "Conference attendance" entry (file mg-conferences-file)
  	"* %^{Conference name}\n:PROPERTIES:\n:WHERE: %?\n:WEBSITE: %?\n:END:\n")
       ("rb" "Book archiving" entry (file+headline mg-books-file "Inbox")
  	"* %^{Book title}\n:PROPERTIES:\n:TITLE: %^{Book title}\n:AUTHOR: %^{Author}\n:YEAR: %^{Year}\n:PAGES: %^{Pages}\n:RATING: %^{Rating (From * to *****)}\n:LINK: %^{Book link}\n:END:\n")
       ("P" "Planning")
       ("Py" "Year plan" plain (file mg-planning-file)
  	"* %^{Year} %U\n- Overview ::\n- Feelings :: %^{Feelings|good|neutral|bad}\n- Milestones ::\n- Values and life philosophy ::\n- 5 years vision(s) ::\n- Financial goals ::\n- [ ] Review ::\n")
       ("Pq" "Quarter plan" plain (file mg-planning-file)
  	"** %^{Quarter} %U\n- Overview ::\n- Feelings :: %^{Feelings|good|neutral|bad}\n- Long-term projects ::\n- Financial/expenses planning ::\n- [ ] Review ::\n")
       ("Pm" "Month plan" plain (file mg-planning-file)
  	"*** %^{Month} %U\n- Overview ::\n- Feelings :: %^{Feelings|good|neutral|bad}\n- Short-term projects ::\n- [ ] Review ::\n")
       ("f" "Flashcards")
       ("fp" "Physics flaschard" entry (file+headline mg-flashcards-file "Physics") "* %(mg-org-capture-generate-flash-header)\n:PROPERTIES:\n:ANKI_DECK: Physics\n:ANKI_NOTE_TYPE: Basic\n:END:\n** Front\n%?\n** Back\n")
       ("fc" "Computer science flashcard" entry (file+headline mg-flashcards-file "Computer science") "* %(mg-org-capture-generate-flash-header)\n:PROPERTIES:\n:ANKI_DECK: Computer science\n:ANKI_NOTE_TYPE: Basic\n:END:\n** Front\n%?\n** Back\n")
       ("fk" "Kernel flashcard" entry (file+headline mg-flashcards-file "Kernel") "* %(mg-org-capture-generate-flash-header)\n:PROPERTIES:\n:ANKI_DECK: Kernel\n:ANKI_NOTE_TYPE: Basic\n:END:\n** Front\n%?\n** Back\n")
       ("fs" "Security flashcard" entry (file+headline mg-flashcards-file "Security") "* %(mg-org-capture-generate-flash-header)\n:PROPERTIES:\n:ANKI_DECK: Security\n:ANKI_NOTE_TYPE: Basic\n:END:\n** Front\n%?\n** Back\n")
       ("fm" "Mathematics flashcard" entry (file+headline mg-flashcards-file "Mathematics") "* %(mg-org-capture-generate-flash-header)\n:PROPERTIES:\n:ANKI_DECK: Mathematics\n:ANKI_NOTE_TYPE: Basic\n:END:\n** Front\n%?\n** Back\n")
       ("fe" "English flashcard" entry (file+headline mg-flashcards-file "English") "* %(mg-org-capture-generate-flash-header)\n:PROPERTIES:\n:ANKI_DECK: English\n:ANKI_NOTE_TYPE: Basic\n:END:\n** Front\n%?\n** Back\n")
       ("p" "Projects")
       ("pl" "Learning project" plain (file+headline mg-personal-projects-file "Learning")
  	"** %^{Project name} [/]\n:PROPERTIES:\n:WHAT: %?\n:REPOSITORY:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")
       ("ph" "Home project" plain (file+headline mg-personal-projects-file "Home")
  	"** %^{Project name} [/]\n:PROPERTIES:\n:WHAT: %?\n:REPOSITORY:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")
       ("pp" "Productivity and tooling project" plain (file+headline mg-personal-projects-file "Productivity and tooling")
  	"** %^{Project name} [/]\n:PROPERTIES:\n:WHAT: %?\n:REPOSITORY:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")
       ("pw" "Work project" plain (file+headline mg-work-projects-file "Work")
  	"** %? [/]\n:PROPERTIES:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")
       ("pr" "Research project" plain (file+headline mg-research-file "Active research projects")
  	"** %? [/]\n:PROPERTIES:\n:RESEARCH_AREAS: %^{Research areas: }\n:COLLABORATORS:\n:CONTEXT:\n:START_DATE: %U\n:END_DATE:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")
       ("pb" "Blogging project" plain (file+headline mg-personal-projects-file "Blogging")
  	"** %? [/]\n:PROPERTIES:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")
       ("ps" "Study project" plain (file+headline mg-work-projects-file "Study")
  	"** %? [/]\n:PROPERTIES:\n:VISIBILITY: hide\n:COOKIE_DATA: recursive todo\n:END:\n*** Details\n*** Tasks\n*** Resources\n*** Artifacts\n*** Logs\n")))
    (org-refile-targets '((mg-work-projects-file :regexp . "\\(?:\\(?:Log\\|Task\\)s\\)")
  			(mg-personal-projects-file :regexp . "\\(?:\\(?:Log\\|Task\\)s\\)")
  			(mg-books-file :regexp . "\\(?:\\(?:2023\\|2024\\)s\\)")
  			(mg-agenda-file :regexp . "\\(?:Past\\)")))
    (org-agenda-block-separator "==============================================================================")
    (org-agenda-custom-commands
     '(("a" "Agenda"
  	((agenda ""
  	       ((org-agenda-span 1)
  		(org-agenda-skip-function
  		 (lambda ()
  		   (org-agenda-skip-entry-if 'done)))
  		(org-deadline-warning-days 0)
  		(org-scheduled-past-days 14)
  		(org-agenda-day-face-function (lambda (date) 'org-agenda-date))
  		(org-agenda-format-date "%A %-e %B %Y")
  		(org-agenda-overriding-header "Today's schedule:\n")))
  	 (todo "DOING"
  	     ((org-agenda-skip-function
  	       '(org-agenda-skip-entry-if 'deadline))
  	      (org-agenda-prefix-format "  %i %-12:c [%e] ")
  	      (org-agenda-overriding-header "\nDOING Tasks:\n")))
  	 (todo "NEXT"
  	     ((org-agenda-skip-function
  	       '(org-agenda-skip-entry-if 'deadline))
  	      (org-agenda-prefix-format "  %i %-12:c [%e] ")
  	      (org-agenda-overriding-header "\nNEXT Tasks:\n")))
  	 (agenda "" ((org-agenda-time-grid nil)
  		   (org-agenda-start-day "+1d")
  		   (org-agenda-start-on-weekday nil)
  		   (org-agenda-span 30)
  		   (org-agenda-show-all-dates nil)
  		   (org-deadline-warning-days 0)
  		   (org-agenda-entry-types '(:deadline))
  		   (org-agenda-skip-function '(org-agenda-skip-entry-if 'done))
  		   (org-agenda-overriding-header "\nUpcoming deadlines (+30d):\n")))
  	 (tags-todo "inbox"
  		  ((org-agenda-prefix-format "  %?-12t% s")
  		   (org-agenda-overriding-header "\nInbox:\n")))
  	 (tags "CLOSED>=\"<today>\""
  	     ((org-agenda-overriding-header "\nCompleted today:\n")))
  	 (agenda ""
  	       ((org-agenda-start-on-weekday nil)
  		(org-agenda-skip-function
  		 (lambda ()
  		   (org-agenda-skip-entry-if 'done)))
  		(org-agenda-start-day "+1d")
  		(org-agenda-span 5)
  		(org-deadline-warning-days 0)
  		(org-scheduled-past-days 0)
  		(org-agenda-overriding-header "\nWeek at a glance:\n")))
  	 ))))
    :config
    (when (display-graphic-p)
      (progn
  	(require 'oc-biblatex)
  	(setq org-cite-export-processors
  	    '((latex biblatex))
  	    org-latex-pdf-process mg-latex-cmds)))
    (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.5)
  	org-format-latex-options (plist-put org-format-latex-options :background "Transparent")
  	org-latex-create-formula-image-program 'dvisvgm)
    (require 'ox-latex)
    ;; discard all intermediary files when exporting to latex
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (setq org-latex-remove-logfilest t)
    (add-to-list 'org-latex-classes
  	       '("res"
  		 "\\documentclass[margin]{res}\n
    \\setlength{\textwidth}{5.1in}"
  		 ("\\section{%s}" . "\\section*{%s}")
  		 ("\\subsection{%s}" . "\\subsection*{%s}")
  		 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  		 ("\\paragraph{%s}" . "\\paragraph*{%s}")
  		 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (add-to-list 'org-latex-classes
  	       '("memoir"
  		 "\\documentclass[article]{memoir}\n
    \\usepackage{color}
    \\usepackage{amssymb}
    \\usepackage{gensymb}
    \\usepackage{nicefrac}
    \\usepackage{units}"
  		 ("\\section{%s}" . "\\section*{%s}")
  		 ("\\subsection{%s}" . "\\subsection*{%s}")
  		 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  		 ("\\paragraph{%s}" . "\\paragraph*{%s}")
  		 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (add-to-list 'org-latex-classes
  	       '("letter"
  		 "\\documentclass{letter}\n"
  		 ("\\section{%s}" . "\\section*{%s}")
  		 ("\\subsection{%s}" . "\\subsection*{%s}")
  		 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  		 ("\\paragraph{%s}" . "\\paragraph*{%s}")
  		 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (add-to-list 'org-latex-classes
  	       '("tuftebook"
  		 "\\documentclass{tufte-book}\n
    \\usepackage{color}
    \\usepackage{amssymb}
    \\usepackage{gensymb}
    \\usepackage{nicefrac}
    \\usepackage{units}"
  		 ("\\section{%s}" . "\\section*{%s}")
  		 ("\\subsection{%s}" . "\\subsection*{%s}")
  		 ("\\paragraph{%s}" . "\\paragraph*{%s}")
  		 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (add-to-list 'org-latex-classes
  	       '("tuftehandout"
  		 "\\documentclass{tufte-handout}
    \\usepackage{color}
    \\usepackage{amssymb}
    \\usepackage{amsmath}
    \\usepackage{gensymb}
    \\usepackage{nicefrac}
    \\usepackage{units}"
  		 ("\\section{%s}" . "\\section*{%s}")
  		 ("\\subsection{%s}" . "\\subsection*{%s}")
  		 ("\\paragraph{%s}" . "\\paragraph*{%s}")
  		 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (add-to-list 'org-latex-classes
  	       '("tufnotes"
  		 "\\documentclass{tufte-handout}
  					 \\usepackage{xcolor}
  					       \\usepackage{graphicx} %% allow embedded images
  					       \\setkeys{Gin}{width=\\linewidth,totalheight=\\textheight,keepaspectratio}
  					       \\usepackage{amsmath}  %% extended mathematics
  					       \\usepackage{booktabs} %% book-quality tables
  					       \\usepackage{units}    %% non-stacked fractions and better unit spacing
  					       \\usepackage{multicol} %% multiple column layout facilities
  					       \\RequirePackage[many]{tcolorbox}
  					       \\usepackage{fancyvrb} %% extended verbatim environments
  						 \\fvset{fontsize=\\normalsize}%% default font size for fancy-verbatim environments

  				\\definecolor{g1}{HTML}{077358}
  				\\definecolor{g2}{HTML}{00b096}

  				%%section format
  				\\titleformat{\\section}
  				{\\normalfont\\Large\\itshape\\color{g1}}%% format applied to label+text
  				{\\llap{\\colorbox{g1}{\\parbox{1.5cm}{\\hfill\\color{white}\\thesection}}}}%% label
  				{1em}%% horizontal separation between label and title body
  				{}%% before the title body
  				[]%% after the title body

  				%% subsection format
  				\\titleformat{\\subsection}%%
  				{\\normalfont\\large\\itshape\\color{g2}}%% format applied to label+text
  				{\\llap{\\colorbox{g2}{\\parbox{1.5cm}{\\hfill\\color{white}\\thesubsection}}}}%% label
  				{1em}%% horizontal separation between label and title body
  				{}%% before the title body
  				[]%% after the title body

  							      \\newtheorem{note}{Note}[section]

  							      \\tcolorboxenvironment{note}{
  							       boxrule=0pt,
  							       boxsep=2pt,
  							       colback={green!10},
  							       enhanced jigsaw,
  							       borderline west={2pt}{0pt}{Green},
  							       sharp corners,
  							       before skip=10pt,
  							       after skip=10pt,
  							       breakable,
  							}"

  		 ("\\section{%s}" . "\\section*{%s}")
  		 ("\\subsection{%s}" . "\\subsection*{%s}")
  		 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  		 ("\\paragraph{%s}" . "\\paragraph*{%s}")
  		 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    (org-babel-do-load-languages
     'org-babel-load-languages '((C . t)
  			       (shell . t)
  			       (python .t)
  			       (emacs-lisp . t)
  			       (org . t)
  			       (gnuplot . t)
  			       (latex . t)
  			       (scheme . t)
  			       (lisp . t)
  			       (haskell . t)
  			       (R . t))))

  ;; Enable and set org-crypt
  (use-package org-crypt
    :ensure nil
    :config
    (org-crypt-use-before-save-magic)
    (setq org-tags-exclude-from-inheritance (quote (crypt)))
    ;; GPG key to use for encryption
    (setq org-crypt-key nil))

  (use-package mg-pkm-utils
    :ensure nil
    :bind (("C-c p c d" . mg-org-compute-deep-work-minutes))
    ("C-c p p" . mg-toggle-pdf-presentation-mode))

  (provide 'mg-emacs-org)
#+end_src

** The ~mg-emacs-denote.el~ module
:PROPERTIES:
:ID:       64ce0bed-fefc-4603-91ef-24b4fd102795
:END:

The second fundamental package that I use for (networked) note-taking is ~denote~. As stated in its README, at its core, it is just an efficient file naming scheme. Clearly, the author built plenty of features on top of this core concept. The package is clean, it reuses a lot of already well-established Emacs features (e.g., ~xref~), and is *extremely* well documented. Moreover, ~denote~ is regularly updated and maintained, so I use the git repository directly with ~straight.el~ to get the bleeding-edge features of it. Shout-out to Prot, who's really the diamond tip of the Emacs community nowadays. I extend ~denote~ on a regular basis, so there is also a custom library I created that is full of features (see [[id:cf17aa34-cd6c-4eea-be80-c111b00f5f3e][The ~mg-denote.el~ library]]).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-denote.el"
  (use-package denote
    :straight t
    :bind (("C-c n n" . denote)
  	 ("C-c n x" . denote-region)
  	 ("C-c n N" . denote-type)
  	 ("C-c n d" . denote-date)
  	 ("C-c n y f" . denote-org-extras-dblock-insert-files)
  	 ("C-c n y l" . denote-org-extras-dblock-insert-links)
  	 ("C-c n y b" . denote-org-extras-dblock-insert-backlinks)
  	 ("C-c n y h" . denote-org-extras-link-to-heading)
  	 ("C-c n s" . denote-sort-dired)
  	 ("C-c n e n" . denote-silo-extras-create-note)
  	 ("C-c n e f" . denote-silo-extras-open-or-create)
  	 ("C-c n t" . denote-template)
  	 ("C-c n i" . denote-link)
  	 ("C-c n I" . denote-add-links)
  	 ("C-c n b" . denote-backlinks)
  	 ("C-c n j n" . denote-journal-extras-new-entry)
  	 ("C-c n j l" . denote-journal-extras-link-or-create-entry)
  	 ("C-c n j j" . denote-journal-extras-new-or-existing-entry)
  	 ("C-c n h" . denote-org-extras-backlinks-for-heading)
  	 ("C-c n g f" . denote-find-link)
  	 ("C-c n g b" . denote-find-backlink)
  	 ("C-c n y s s" . denote-sequence)
  	 ("C-c n y s r" . denote-sequence-reparent)
  	 ("C-c n y s d" . denote-sequence-dired)
  	 ("C-c n y s f" . denote-sequence-find)
  	 ("C-c n y s l" . denote-sequence-link)
  	 ("C-c n y s c s" . denote-sequence-new-sibling-of-current)
  	 ("C-c n y s c c" . denote-sequence-new-child-of-current)
  	 ("C-c n r" . denote-rename-file)
  	 ("C-c n R" . denote-rename-file-using-front-matter))
    :init
    (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
    :custom
    (denote-known-keywords '("emacs" "security" "kernel" "mathematics" "algorithms"))
    (denote-infer-keywords t)
    (denote-sort-keywords t)
    (denote-file-type nil)
    (denote-prompts '(title keywords file-type template signature))
    (denote-excluded-directories-regexp nil)
    (denote-excluded-keywords-regexp nil)
    (denote-date-prompt-use-org-read-date t)
    (denote-date-format nil)
    (denote-rename-buffer-format "[D] %s %t (%k)")
    (denote-backlinks-show-context t)
    (denote-dired-directories
     (list denote-directory
  	 (thread-last denote-directory (expand-file-name "assets"))))
    (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
    (denote-templates
     '((plain . "")
       (course . "#+include: \"~/.emacs.d/headers/header_notes_document_small.org\"\n* Course details\n- Lecturer ::\n- University ::\n- Academic year ::\n- Resources ::\n- Description ::\n* Lecture notes\n")
       (zettel . "#+references: \n\n\n-----\n")
       (place . "* Details\n- Link ::\n- Visited ::\n- Description ::\n* Notes\n")
       (contact . "* Contact details\n- E-mail ::\n- Company ::\n- Phone number ::\n- Website ::\n- Twitter ::\n- Additional information ::\n* Notes")))
    (denote-date-prompt-use-org-read-date t)
    (denote-sequence-scheme 'alphanumeric)
    :config
    (denote-rename-buffer-mode 0)
    ;; Due to an org-mode bug, some ~dblock~ functions are not loaded automatically
    (require 'denote-org-extras)
    (require 'denote-sequence))

  (use-package mg-denote
    :ensure nil
    :bind
    (("C-c n f f" . mg-denote-find-file)
     ("C-c n z f" . mg-denote-find-zettel)
     ("C-c n z g" . mg-denote-grep-on-zettels)
     ("C-c n y s i" . mg-denote-get-index-in-dired)
     ("C-c n u" . mg-denote-copy-timestamp-to-killring)
     ("C-c n o r" . mg-denote-copy-to-assets-and-rename)
     ("C-c n z i" . mg-denote-insert-zettel-link)))

  (use-package denote-search
    :straight (denote-search :type git :host github :repo "lmq-10/denote-search" :branch "main")
    :bind
    (("C-c n f s" . denote-search)))

  (use-package denote-explore
    :straight t
    :custom
    (denote-explore-network-directory (concat denote-directory "/.graphs"))
    (denote-explore-network-filename "denote-network")
    (denote-explore-network-format 'gexf)
    (denote-explore-network-graphviz-filetype "gexf"))

  (use-package denote-menu
    :straight t
    :config
    :bind (("C-c n m l" . list-denotes)
  	 ("C-c n m f" . denote-menu-filter-by-keyword)))

  (use-package consult-denote
    :straight t
    :bind (("C-c n f g" . consult-denote-grep)
  	 ("C-c n f c" . consult-denote-find)))

  (provide 'mg-emacs-denote)
#+end_src

** The ~mg-emacs-bib.el~ module
:PROPERTIES:
:ID:       39930734-961e-4da9-9df4-a9e7e4223e2b
:END:

This module introduces several packages that I use to manage bibliographic entries and references in general. In my research work, is super important to have a tidied, smooth and efficient way of managing these things. I use ~citar~ as the main bibliography manager, and the I use ~citar-denote~ and ~citar-embark~ on top of it. The former is actually extremely convenient for people like me using ~denote~ (see [[id:64ce0bed-fefc-4603-91ef-24b4fd102795][The ~mg-emacs-denote.el~ module]]) as their note-taking tool of choice: it allows to link reference notes to bibliography entries, and have a convenient way to search notes and open associated artifacts (e.g., PDF files or web pages).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-bib.el"
  (use-package citar
    :straight t
    :custom
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-templates
     '((main . "${author editor:30}     ${date year issued:4}     ${title:48}")
       (suffix . "          ${=key= id:15}    ${=type=:12}")
       (preview . "${author editor} (${year issued date}) ${title}, ${journal journaltitle publisher}.\n")
       (note . "@${author editor}, ${title}")))
    (citar-symbol-separator "  ")
    :bind
    (("C-c n c o" . citar-open)
     ("C-c n c b" . citar-open-entry)
     (:map org-mode-map :package org ("C-c b" . #'org-cite-insert)))
    :config
    (setq citar-bibliography (list mg-bibliography-path)))

  (use-package citar-denote
    :straight t
    :custom
    (citar-open-always-create-notes nil)
    (citar-denote-file-type 'org)
    (citar-denote-subdir nil)
    (citar-denote-keyword "bib")
    (citar-denote-use-bib-keywords nil)
    (citar-denote-title-format "title")
    (citar-denote-title-format-authors 1)
    (citar-denote-title-format-andstr "and")
    (citar-denote-template "- Research question ::\n- Sketch solution ::\n")
    :init
    (citar-denote-mode)
    :bind (("C-c n c c" . citar-create-note)
	 ("C-c n c n" . citar-denote-open-note)
	 ("C-c n c d" . citar-denote-dwim)
	 ("C-c n c e" . citar-denote-open-reference-entry)
	 ("C-c n c a" . citar-denote-add-citekey)
	 ("C-c n c k" . citar-denote-remove-citekey)
	 ("C-c n c r" . citar-denote-find-reference)
	 ("C-c n c f" . citar-denote-find-citation)
	 ("C-c n c l" . citar-denote-link-reference)))

  (use-package biblio
    :straight t
    :bind (("C-c p b b" . biblio-lookup)))

  (use-package mg-bib
    :ensure nil
    :after (org)
    :bind (("C-c p b r" . mg-bib-search-add-to-reading-list)
	 ("C-c p b c" . mg-bib-count-references)
	 ("C-c p b n" . mg-bib-denote-goto-notes-interactively)
	 ("C-c p b i" . mg-bib-kill-bibtex-from-isbn)))

  (use-package mg-personal
    :ensure nil)

  (provide 'mg-emacs-bib)
#+end_src

** The ~mg-emacs-ledger.el~ module
:PROPERTIES:
:ID:       5fb29d20-1803-4301-80ff-d05d53397166
:END:

I use the ~hledger~ CLI tool to track my finances. I tried both ~ledger~ and ~hledger~, and I find the latter more sophisticated and feature-rich. The documentation is also significantly better, which played a huge role in picking between the two. They belong to the plain-text and double-entry type of accounting software, widely used and proved to reduce inconsistencies and errors (see also [[https://hledger.org/accounting.html]]). I do the whole finance tracking with an ~org-mode~ file and ~babel~ to then export is as a ~ledger~ journal. In this way, I can later parse it with ~hledger~ and run queries on it.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-ledger.el"
  (use-package ledger-mode
    :straight t
    :init
    (defconst mg-ledger-bin "/usr/bin/hledger")
    :mode ("\\.journal\\'" "\\.ledger\\'" "\\.hledger\\'")
    :custom
    (ledger-binary-path mg-ledger-bin)
    (ledger-mode-should-check-version nil)
    (ledger-report-auto-width nil)
    (ledger-report-use-native-highlighting nil))

  (provide 'mg-emacs-ledger)
#+end_src

** The ~mg-emacs-flashcards.el~ module
:PROPERTIES:
:ID:       93af5e84-4396-4994-9804-3edc69d8a070
:END:

Spaced repetition is perhaps the only scientific approach to the learning process that has been discovered in the last years. Its effects are tangible and widely studied (see [[https://gwern.net/spaced-repetition]]). To this end, I use a connection between org-mode and [[https://apps.ankiweb.net/][Anki]] to conveniently write and review cards. I have used other org-centered alternatives (e.g., [[https://github.com/l3kn/org-fc][org-fc]] and [[https://orgmode.org/worg/org-contrib/org-drill.html][org-drill]]), but I think reviewing cards also /"on-the-go"/ through a mobile up is a potential speedup in the learning process. I take the use of Anki instead of org-centered alternatives as a test: in case it doesn't provide measurable benefits, I'll go back.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-flashcards.el"
  (use-package anki-editor
    :straight (:type git :host github :repo "anki-editor/anki-editor" :branch "master")
    :bind
    (("C-c o a i" . anki-editor-insert-note)
     ("C-c o a p" . anki-editor-push-notes)))

  (provide 'mg-emacs-flashcards)
#+end_src

** The ~mg-emacs-notmuch.el~ module

I started using ~notmuch~ not so long ago. During a conversation with [[https://protesilaos.com/][Protesilaos Stavrou]], I realized that ~notmuch~ was far better than ~mu4e~, given the specific use cases and needs I had. Therefore, after ~ 2 years of me using ~mu4e~, I gave ~notmuch~ a try. Most of the configuration is done outside Emacs, by tweaking tools as ~msmtp~ and ~mbsync~, and ~notmuch~ itself, which is basically a CLI e-mail indexer. The following piece of code tweaks a couple of important options, and then it is mainly cosmetics.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-notmuch.el"
  (use-package notmuch
    :straight t
    :bind (
  	 :map global-map
  	 ("C-x m" . nil)
  	 ("C-x m o" . notmuch)
  	 :map notmuch-search-mode-map
  	 ("a" . nil)
  	 ("A" . nil)
  	 ("/" . notmuch-search-filter)
  	 ("r" . notmuch-search-reply-to-thread)
  	 ("R" . notmuch-search-reply-to-thread-sender)
  	 :map notmuch-show-mode-map
  	 ("a" . nil)
  	 ("A" . nil)
  	 ("r" . notmuch-show-reply)
  	 ("R" . notmuch-show-reply-sender))
    :custom
    (notmuch-show-logo nil)
    (notmuch-search-oldest-first nil)
    (notmuch-archive-tags nil
  			notmuch-message-replied-tags '("+replied")
  			notmuch-message-forwarded-tags '("+forwarded")
  			notmuch-show-mark-read-tags '("-unread")
  			notmuch-draft-tags '("+draft")
  			notmuch-draft-folder "drafts"
  			notmuch-draft-save-plaintext 'ask)
    (notmuch-show-relative-dates t)
    (notmuch-show-all-multipart/alternative-parts nil)
    (notmuch-show-indent-messages-width 0)
    (notmuch-show-indent-multipart nil)
    (notmuch-show-part-button-default-action 'notmuch-show-view-part)
    (notmuch-show-text/html-blocked-images ".") ; block everything
    (notmuch-wash-wrap-lines-length 120)
    (notmuch-unthreaded-show-out nil)
    (notmuch-message-headers '("To" "Cc" "Subject" "Date"))
    (notmuch-message-headers-visible t)
    :config
    (add-to-list 'notmuch-saved-searches '(:name "mm" :query "tag:mm" :key "m"))
    (defun pop-from-message-completion()
      (pop message--old-style-completion-functions))
    (advice-add 'message-completion-function :after #'pop-from-message-completion)
    (let ((count most-positive-fixnum))
      (setq notmuch-wash-citation-lines-prefix count
  	  notmuch-wash-citation-lines-suffix count)))

  (use-package ol-notmuch
    :straight (ol-notmuch :type git :host github :repo "tarsius/ol-notmuch")
    :after notmuch)

  (use-package mg-notmuch
    :ensure nil
    :after notmuch
    :bind (("C-x m u" . mg-notmuch-update-mail))
    :config

    (setq notmuch-hello-refresh-hook #'mg-notmuch-update-mail))

  (provide 'mg-emacs-notmuch)
  ;;; mg-emacs-notmuch.el ends here
#+end_src

** The ~mg-emacs-languages.el~ module

This module handles all language-specific options, either for markup ones or for programming. It is therefore full of stuff, so maybe in the future it would be better to divide it into smaller sub-modules.

I very rarely use Markdown, mostly when formatting text to send it later on Slack or related software. The workflow I've been having (that should change sooner or later) is to just open a temporary buffer, turn ~markdown-mode~ on, write the formatted message, and then send it on Slack. I'd rather go with an automated feature that enables all of that automatically without the need to do everything by hand (e.g., press a keystroke, and choose the mode interactively, and just spawn the buffer with that mode).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-languages.el"
  (use-package markdown-mode
    :straight t
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))
#+end_src

Since natural language is still a language, let's enable spellchecking in this module.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-languages.el"
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
#+end_src

Since I work with the Linux kernel every single day, I want Emacs to format C code as stated by the kernel community's directives. The code below sets the C style to be compliant to those directives.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-languages.el"
  (setq c-default-style "linux")
#+end_src

The following is a series of packages to enable LSP and major-modes for some programming languages. I've been using ~eglot~ as LSP client for quite a while now, and I'd say that I'm really satisfied with it. The code below is basically a setup of some configuration options for ~eglot~ (already shipped with Emacs 29) and the declarations for some programming modes. I used ~lsp-mode~ in the past, but I think ~eglot~ has the perfect balance between simplicity and feature-richness.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-languages.el"
  (use-package dockerfile-mode
    :straight t
    :mode "\\.docker.file\\'" "\\Dockerfile\\'")

  (use-package haskell-mode
    :straight t
    :mode "\\.hs\\'")

  (use-package bpftrace-mode
    :straight t
    :mode "\\.bt\\'")

  (use-package racket-mode
    :straight t
    :mode "\\.rkt\\'")

  (use-package python-mode
    :straight t
    :mode "\\.py\\'")

  (use-package edts
    :straight t)

  (use-package erlang-mode
    :ensure nil
    :after (edts)
    :mode "\\.erl\\'")

  (use-package gnuplot
    :straight t)

  (use-package fasm-mode
    :straight t)

  (use-package pyvenv
    :straight t)

  (provide 'mg-emacs-languages)
#+end_src

** The ~mg-emacs-browsing.el~ module

In this module, I enable some of the packages I use for browsing the web. The preferred way to do so is clearly a full-fledged web browser, but I often type queries directly in Emacs using ~engine-mode~. For fast searches and plain HTML websites, ~eww~ is a convenient Emacs-based alternative to a standard web browser.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-browsing.el"
  (use-package engine-mode
    :straight t
    :config
    (engine/set-keymap-prefix (kbd "C-c u e"))
    (defun mg-engine-mode-exact-phrase-transform (search-term)
      (if current-prefix-arg
  	(concat "\"" search-term "\"")
        search-term))
    (defengine archwiki
      "https://wiki.archlinux.org/index.php?search=%s"
      :keybinding "a")
    (defengine google
      "http://www.google.com/search?hl=en&ie=utf-8&oe=utf-8&q=%s"
      :keybinding "g"
      :term-transformation-hook mg-engine-mode-exact-phrase-transform)
    (defengine elixir
      "https://elixir.bootlin.com/linux/latest/A/ident/%s"
      :keybinding "k")
    (defengine kernel-documentation
      "https://www.kernel.org/doc/html/v4.12/core-api/kernel-api.html#c.%s"
      :keybinding "d")
    (defengine syscall-table
      "https://syscalls.mebeim.net/?table=x86/64/x64/latest"
      :keybinding "s")
    (defengine google-maps
      "https://www.google.com/maps/search/%s/"
      :keybinding "M")
    (defengine semantic-scholar
      "https://www.semanticscholar.org/search?q=%s&sort=relevance"
      :keybinding "r")
    (defengine openstreetmap
      "https://www.openstreetmap.org/search?query=%s"
      :keybinding "m")
    (defengine wordreference-iten
      "https://www.wordreference.com/iten/%s"
      :keybinding "i")
    (defengine wordreference-enit
      "https://www.wordreference.com/enit/%s"
      :keybinding "e")
    (defengine wikipedia
      "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
      :keybinding "w")
    (defengine youtube
      "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
      :keybinding "y")
    (engine-mode t))

  (use-package eww
    :ensure nil
    :config
    (setq shr-use-fonts nil)
    (setq shr-color-visible-luminance-min 80)
    (setq shr-use-colors nil))

  (provide 'mg-emacs-browsing)
#+end_src

** The ~mg-emacs-git.el~ module

I use ~magit~ as git client for Emacs. I think it is, along with ~org-mode~, the most impactful Emacs package I have ever used. There is nothing more to add. Besides ~magit~, I used ~git-email~, which is a simple package that allows to send e-mails with git patches directly in Emacs. Starting from Emacs 29, they introduced ~vc-prepare-patch~ natively, which basically covers the same features of ~git-email~ (see [[https://lists.sr.ht/~yoctocell/git-email-devel/%3Ccc4a1b8b-9a1d-46cf-9b04-466c85ebcd44%40riseup.net%3E]]). There is not much to configure in ~magit~, just some formatting configurations just for being compliant to the Linux kernel's coding (and patching) guidelines.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-git.el"
  (use-package magit
    :straight t
    :bind (("C-c x" . magit))
    :config
    (setf (alist-get 'unpushed magit-section-initial-visibility-alist) 'show)
    (setq magit-refresh-status-buffer t)
    (setq git-commit-fill-column 75))

  (provide 'mg-emacs-git)
#+end_src

** The ~mg-emacs-programming.el~ module
:PROPERTIES:
:ID:       603EA351-F695-447C-A2EB-AD7FB7C61E5E
:END:

In this module, I pull and enable several coding-related packages, regardless of their specific functionality: they could either allow to inspect code, execute diffs, move cursors around. I don't know whether I should further sub-categorize them, but for now it's better to stick with this solution. Some of these packages are crucial for my work with the Linux kernel (e.g., ~xcscope~, ~multiple-cursors~), and I use them extensively, while I use others very rarely (e.g., ~ztree~).

Having multiple cursors is a neat feature that changed the way I look and modify source code. I started to realize how many times we have common patterns that we repeatedly modify, wasting time and energy. Whenever you realize this fact, having multiple cursors and edit different parts of the text at the same time is a valuable feature that could hardly be ignored. The ~multiple-cursor~ package does the job wonderfully.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-programming.el"
  (use-package multiple-cursors
    :after (org)
    :straight t
    :bind (("C-c m >" . #'mc/mark-next-like-this)
  	 ("C-c m <" . #'mc/mark-previous-like-this)
  	 ("C-c m -" . #'mc/mark-next-like-this-word)
  	 ("C-c m e" . 'mc/mark-more-like-this-extended)
  	 ("C-c m s" . 'mc/mark-all-dwim)
  	 ("C-c m a" . mc/mark-all-like-this)
  	 ("C-c m r" . mc/mark-all-in-region)
  	 ("C-c m d" . mc/mark-all-like-this-dwim)
  	 ("C-c m w" . mc/mark-all-words-like-this))
    :custom
    (mc/always-run-for-all t)
    :init
    (require 'multiple-cursors)
    (define-key mc/keymap (kbd "<return>") nil)
    :config
    (multiple-cursors-mode 1))
#+end_src

The following packages, instead, are mostly for source code analysis and browsing. For sure, ~xcscope~ is the killer package here, and I use it every day multiple times. When it comes to inspecting *huge* codebases (e.g., the Linux kernel), having an efficient way to find definitions, function calling another function, patterns, etc. is fundamental. The ~xcscope~ package is just a ~cscope~ client for Emacs (to make ~cscope~ to work you typically have to build a ~cscope~ "database" - e.g., in the Linux kernel you simply type ~make cscope~).

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-programming.el"
  (use-package deadgrep
    :straight t
    :bind
    (("M-g r" . deadgrep)))

  (use-package xcscope
    :straight t
    :bind
    (("C-c s s" . cscope-find-this-symbol)
     ("C-c s d" . cscope-find-global-definition)
     ("C-c s c" . cscope-find-functions-calling-this-function)
     ("C-c s x" . cscope-set-initial-directory)
     ("C-c s f" . cscope-find-this-file))
    :config
    (cscope-setup))

  (use-package ediff
    :straight t
    :config
    (set 'ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

Although I do not use it just for coding (but for templates in general, even in org files), ~yasnippet~ is another great tool that I leverage upon.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-programming.el"
  (use-package yasnippet
    :straight t
    :init
    (defconst mg-snippets-dir ".snippets")
    :custom
    (yas-snippet-dirs (list (format "%s/%s" mg-emacs-root mg-snippets-dir)))
    :config
    (yas-global-mode 1))
#+end_src

I mostly write and review code for the [[https://kernel.org/][Linux kernel]]. I have a custom library with some useful functions I use on my daily work. They are not ground-breaking, rather they just speed-up some repeated operations.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-programming.el"
  (use-package mg-kernel
    :ensure nil
    :after (cc-mode)
    :bind
    (:map c-mode-map
  	("C-c v" . mg-get-kernel-version-from-source)
  	("C-c ." . mg-kernel-do-grep)))
#+end_src

The following piece of code introduces ~vterm~ as terminal emulator, with ~multi-vterm~ on top of it. I've been using ~vterm~ since the very beginning, and never felt the need to switch to any other terminal emulator (e.g., ~eshell~). The ~multi-vterm~ package, instead, allows to spawn multiple ~vterm~ buffer, that in conjunction with window splitting and multiple buffer basically creates a "terminal multiplexer" inside of Emacs.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-programming.el"
  (when (display-graphic-p)
    (progn
      (use-package vterm
        :straight t)
      (use-package multi-vterm
        :straight t
        :bind (("C-c v" . multi-vterm)))))

  (provide 'mg-emacs-programming)
#+end_src

** The ~mg-emacs-ai.el~ module

Starting from [2024-10-15 Tue], I plan to use open-source LLMs to help in my research work. This includes summarizing text, spell-checking and rephrasing. Although some skepticism, I found that these tools can substantially help us with some tasks related to the writing process, either it is for research or note-taking. As far as Emacs is concerned, these tools can be deeply integrated in one's workflow and generally provide a smooth experience without the pain of using webapps or other bloated nonsense.

#+begin_src emacs-lisp :tangle "mg-emacs-modules/mg-emacs-ai.el"
  (use-package ellama
    :straight t
    :custom
    (ellama-keymap-prefix "C-c u a")
    (ellama-language "English")
    :config
    (require 'llm-ollama)
    (if (eq system-type 'darwin)
        (setq ellama-provider
  	    (make-llm-ollama
  	     :chat-model "llama3.3:70b"))
      (setq ellama-provider
  	  (make-llm-ollama
  	   :chat-model "llama3.2:latest"))))

  (provide 'mg-emacs-ai)
#+end_src

* The ~mg-custom-modules~ libraries
** The ~mg-utils.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-utils.el" :mkdirp yes
  ;;; mg-utils.el --- Custom utility functions for Emacs Lisp coding -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.3"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces some utility functions that I find useful when coding in Emacs Lisp.

  ;;; Code:

  (defconst mg-work-laptop-hostname "nano"
    "This constant keeps track of the hostname I have on my Linux work laptop.")

  (defconst mg-personal-laptop-hostname "think"
    "This constant keeps track of the hostname I have on my Linux personal laptop.")

  (defconst mg-pkm-base-directory "~/Vault/pkm"
    "This constant keeps track of the base directory for my entire knowledge base.")

  (defconst denote-directory (expand-file-name mg-pkm-base-directory)
    "This constant keeps track of the denote directory for my entire knowledge base.")

  (defconst mg-pkm-assets-directory (expand-file-name "assets/" denote-directory)
    "This constant keeps track of the assets directory for my entire knowledge base.")

  (defconst mg-work-projects-file (format "%s/%s" denote-directory "20231210T220334--work-and-study-projects__project_work.org")
    "This constant keeps track of the work and project file within my knowledge base.")
  (defconst mg-inbox-file (format "%s/%s" denote-directory "20231211T145832--inbox__gtd_personal.org")
    "This constant keeps track of the inbox file within my knowledge base.")
  (defconst mg-agenda-file (format "%s/%s" denote-directory "20231210T224321--agenda__personal.org")
    "This constant keeps track of the agenda file within my knowledge base.")
  (defconst mg-archive-file (format "%s/%s" denote-directory ".archive/archive.org")
    "This constant keeps track of the archive file within my knowledge base.")
  (defconst mg-research-file (format "%s/%s" denote-directory "20231213T175339--research__metanote_planning.org")
    "This constant keeps track of the research metanote file within my knowledge base.")
  (defconst mg-capture-notes-file (format "%s/%s" denote-directory "20231213T172757--capture-notes__gtd_personal.org")
    "This constant keeps track of the capture notes file within my knowledge base.")
  (defconst mg-conferences-file (format "%s/%s" denote-directory "20231210T222135--conferences__personal_research.org")
    "This constant keeps track of the conferences file within my knowledge base.")
  (defconst mg-personal-projects-file (format "%s/%s" denote-directory "20231210T220139--personal-projects__personal_project.org")
    "This constant keeps track of the personal projects file within my knowledge base.")
  (defconst mg-books-file (format "%s/%s" denote-directory "20240102T104309--books__personal_reading.org")
    "This constant keeps track of the books file within my knowledge base.")
  (defconst mg-planning-file (format "%s/%s" denote-directory "20240104T191508--planning__personal_planning.org")
    "This constant keeps track of the planning file within my knowledge base.")
  (defconst mg-flashcards-file (format "%s/%s" denote-directory "20240220T165813--flashcards__learning_personal.org")
    "This constant keeps track of the flashcards file within my knowledge base.")
  (defconst mg-reading-list-file (format "%s/%s" denote-directory "20241130T124328--reading-list__metanote_research.org")
    "This constant keeps track of the reading list file within my knowledge base.")
  (defconst mg-references-file (format "%s/%s" denote-directory "20241204T111546--references__main_metanote_research.org")
    "This constant keeps track of the references file within my knowledge base.")
  (defconst mg-bibliography-path "~/Vault/research/references.bib"
    "This constant keeps track of my references bibtex file.")
  (defconst mg-latex-cmds '("latexmk -pdflatex='lualatex -shell-escape -interaction nonstopmode' -pdf -f  %f")
    "This constant keeps track of the latex command I use to export from org-mode.")

  (defun mg-get-today-timestamp ()
    "Helper function to get today's timestamp with the abbreviated day name."
    (format-time-string "%Y-%m-%d %a"))

  (defun mg-connected-via-ssh-p ()
    "Return non-nil if connected via `ssh` to a remote machine."
    (not (string-empty-p
  	(string-trim (shell-command-to-string "echo $SSH_TTY")))))

  (provide 'mg-utils)
  ;;; mg-utils.el ends here
#+end_src

** The ~mg-emacs.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-emacs.el"
  ;;; mg-emacs.el --- Custom emacs functionalities -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.4"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces some customizations within the Emacs text
  ;; editor. Its purpose its mainly to have some convenient
  ;; functionalities built on top of the Emacs base.

  ;;; Code:

  (defvar mg-screenshots-directory "~/.screenshots"
    "Directory for storing screenshots.

    This directory is used by the `mg-take-screenshot' function to
    store screenshots obtained with scrot.")

  (defconst mg-scrot-command "/usr/bin/scrot -s "
    "This is the \"scrot\" command to use to take a screenshot and save it.")

  (defun mg-insert-today-timestamp-formatted ()
    "Insert a timestamp of today at the current point.

    The timestamp is formatted around square brackets, which is the
    typical way I specify the date. The square bracketed date have a
    specific meaning in org-mode, but here we assume the date is
    inserted in a non-org file, or that it is not meaningful for
    agenda purposes."
    (interactive)
    (insert (format "[%s]" (mg-get-today-timestamp))))

  (defun mg-take-screenshot ()
    "Take a screenshot using \"scrot\".

    The file will be saved under the `mg-screenshots-directory'. Since
    screenshots are meant to be further categorized, a \"RENAME\"
    string is added before the \"png\" extension."
    (interactive)
    (let ((screenshot-name (format "%s/%s" mg-screenshots-directory (format-time-string "%Y-%m-%d-%H-%M_screenshot_RENAME.png"))))
      (shell-command (concat mg-scrot-command screenshot-name))))

  (defun mg-add-current-file-name-to-killring ()
    "Add the file name visited by the current buffer to the killring."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
  		      default-directory
  		    (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Added file name '%s' to the killring." filename))))

  (provide 'mg-emacs)
  ;;; mg-emacs.el ends here
#+end_src

** The ~mg-defaults-extensions.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-defaults-extensions.el"
  ;;; mg-emacs-default-extensions.el --- Sane extensions to the defaults for Emacs  -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.3"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This source file introduces some extensions (e.g., minor/major
  ;; modes) to the ones I usually enable when using Emacs.

  ;;; Code:
  (define-minor-mode mg-line-numbers-highlight-line-mode
    "This minor mode shows line numbers in relative mode and
  highlights the current line. I use it extensively when in coding."
    :initial nil
    (if mg-line-numbers-highlight-line-mode
        (progn
  	(display-line-numbers-mode 1)
  	(hl-line-mode 1)
  	(setq display-line-numbers-type 'relative))
      (progn
        (display-line-numbers-mode 0)
        (hl-line-mode 0))))

  (provide 'mg-defaults-extensions)
  ;;; mg-defaults-extensions.el ends here
#+end_src

** The ~mg-modeline.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-modeline.el"
  ;;; mg-modeline.el --- Custom modeline for the Emacs editor -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.4"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This source file defines a custom modeline for the Emacs editor. It
  ;; has a cleaner structure compared to the original one, and
  ;; highlights buffer state (i.e., local vs. remote, saved vs. unsaved)
  ;; more clearly.

  ;;; Code:

  (defvar mg-modeline-buffer-status
    '(:eval
      (if (file-remote-p default-directory)
  	(propertize " @ "
  		    'mouse-face 'mode-line-highlight)
        (propertize " ^ "
  		  'mouse-face 'mode-line-highlight)))
    "This is the propertized variable containing the status of the
  current buffer. The status specifies whether this buffer is
  remote or local.")

  (defvar mg-modeline-buffer-name
    '(:eval
      (propertize (buffer-name) 'face 'mode-line-buffer-id))
    "This is the propertized variable containing the current buffer's
  name.")

  (defun mg-modeline--major-mode ()
    "Get the current major mode for the opened buffer. The major mode
  is obtained by looking at the `major-mode' variable. In case we
  are under EXWM, the major mode haas also a `exwm--input-mode'
  further specification (i.e., Char or Line) that is also useful to
  specify in the modeline."
    (let* ((mode
  	  (mapconcat 'capitalize
  		     (butlast (split-string (symbol-name major-mode) "-")) " "))
  	 (mode-final
  	  (if (string-equal mode "Exwm")
  	      (concat "Exwm: "
  		      (mapconcat 'capitalize
  				 (butlast (split-string (symbol-name exwm--input-mode) "-"))))
  	    mode))
  	 (indicator (cond
  		     ((derived-mode-p 'text-mode) "§")
  		     ((derived-mode-p 'prog-mode) "λ")
  		     ((derived-mode-p 'comint-mode) ">_")
  		     (t "o"))))
      (format "%s (%s)" indicator mode-final)))

  (defvar mg-modeline-major-mode
    '(:eval
      (mg-modeline--major-mode))
    "This is the variable containing the major mode for the current
   buffer, as returned by the `mg-modeline--major-mode' function")

  (defvar mg-modeline-buffer-mode
    '(:eval
      (if buffer-read-only
  	"*L*"
        "*U*"))
    "This is the variable indicating whether the buffer is in
   read-only mode or not." )

  (setq-default mode-line-format
  	      '("%e"
  		mg-modeline-buffer-status
  		mg-modeline-buffer-mode
  		" "
  		mg-modeline-buffer-name
  		" "
  		mode-line-position
  		"  "
  		'(:eval (propertize vc-mode 'face 'mode-line-buffer-id))
  		"  "
  		mg-modeline-major-mode
  		"  "
  		'(:eval
  		 (when (mode-line-window-selected-p)
  		   (propertize mode-line-end-spaces 'face '(:foreground "black"))))))

  (dolist (construct
  	 '(mg-modeline-major-mode
  	   mg-modeline-buffer-mode
  	   mg-modeline-buffer-status
  	   mg-modeline-buffer-name))
    (put construct 'risky-local-variable t))

  (provide 'mg-modeline)
  ;;; mg-modeline.el ends here
#+end_src

** The ~mg-macos.el~ library
:PROPERTIES:
:ID:       93f60f28-3019-4010-9012-f7897dc3b873
:END:

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-macos.el"
  ;;; mg-macos.el --- Enable macos support -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.3"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This source file just enables some options to make Emacs smooth on
  ;; `darwin' as well. Nothing more.

  ;;; Code:

  (defun mg-macos-support-enable ()
    "This function simply turns some options on, for me to have a
   smooth experience with Emacs even on `darwin'."
    (progn
      (setenv "LANG" "en_US.UTF-8")
      (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
      (add-to-list 'default-frame-alist '(ns-appearance . dark))
      (setq ns-use-proxy-icon nil
  	  mac-option-modifier 'meta
  	  frame-title-format nil
  	  mac-frame-tabbing nil)
      (menu-bar-mode t)))

  (provide 'mg-macos)
  ;;; mg-macos.el ends here
#+end_src

** The ~mg-org.el~ library
:PROPERTIES:
:ID:       DBAFB68B-2ADF-412F-9155-4A0107C20B0F
:END:

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-org.el"
  ;;; mg-org.el --- Org-mode custom extensions -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.3"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces some custom Emacs Lisp code to extend
  ;; `org-mode', which is one of the Emacs packages that I use the most.

  ;;; Code:

  ;; Required for string-trim function
  (require 'subr-x)
  (defun mg-extract-heading-name (heading)
    "Extract the heading name, handling text before links, links, and task indicators."
    ;; Remove task progress indicators like [1/1] and trim trailing spaces
    (setq heading (string-trim (replace-regexp-in-string "\\[\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*" "" heading)))
    ;; Function to extract and concatenate text before the link and the link description
    (let ((start 0) (parts '()))
      (while (string-match "\\(.*?\\)\\(\\[\\[.*?\\]\\[\\(.*?\\)\\]\\]\\)" heading start)
        (push (match-string 1 heading) parts)  ; Text before the link
        (push (match-string 3 heading) parts)  ; Link description
        (setq start (match-end 0)))
      (push (substring heading start) parts)  ; Remaining text after last link
      (string-join (reverse parts) "")))

  (defun mg-org-get-clock-minutes (file start-date end-date)
    "Get minutes from org-clock of a specific file and date."
    (interactive
     (list
      (read-file-name "Get clock data from FILE: ")
      (format "<%s>" (org-read-date))
      (format "<%s>" (org-read-date))))
    (let ((minutes (nth 1
  		      (with-current-buffer (find-file-noselect file)
  			(org-clock-get-table-data file `( :maxlevel 4
  							  :tstart ,start-date
  							  :tend ,end-date))))))
      minutes))

  (defun mg-org-get-tasks ()
    "Get active tasks from all `org-agenda-files'.

    This function returns a list of tasks taken from files belonging
    to the `org-agenda-files' list. NOTE: It needs to be tweaked and
    generalized to filter based on `org-todo-keywords'."
    (let ((tasks nil))
      (dolist (file org-agenda-files)
        (let* ((buffer-exists (get-file-buffer file))
    	     (buffer (or buffer-exists (find-file-noselect file))))
    	(with-current-buffer buffer
    	  (let ((task-list (save-excursion
    			     (org-agenda-get-todos))))
    	    (push task-list tasks)))
    	(unless buffer-exists
    	  (kill-buffer buffer))))
      (flatten-tree tasks)))

  (defun mg-org--task-prompt ()
    "Prompt the user for a task.

  The task can be selected from the list of tasks returned by
  `mg-org-get-tasks'."
    (completing-read "Select task: " (mg-org-get-tasks) nil :require-match))

  (defun mg-org-block-time ()
    "Prompt the user for time and task and block time.

  The user is continuously prompted with a date-time to select -
  the current day is supposed to be selected -, and it prompts the
  a list of pending org-agenda todo tasks. It creates and hidden
  file with the time-blocking and then it adds it to the
  `org-agenda-files'."
    (interactive)
    (let ((default-directory "/tmp/"))
      (with-current-buffer (find-file (format ".%s--timeblock.org" (format-time-string "%Y%m%dT%H%M%S")))
        ;; In case of one file, to avoid overwritting stuff:
        ;; (goto-char (point-max))
        (org-agenda-file-to-front)
        (catch 'no-time
    	(while t
    	  (let ((time (org-read-date)))
    	    (unless (string-match-p "[0-9-]\\{10\\} .*" time)
    	      (throw 'no-time time))
    	    (insert (format "* %s\n" (string-trim (mg-org--task-prompt))))
    	    (insert (format "SCHEDULED: <%s>\n\n" time))))))))

  (defvar my-org-export-functions
    '((html-buffer . org-html-export-as-html)
      (latex-buffer . org-latex-export-as-latex)))

  (defvar my-org-select-export-history nil)

  (defun my-org-select-export-function ()
    (let ((default (car my-org-select-export-history)))
      (intern
       (completing-read
        (format-prompt "Select export type" default)
        my-org-export-functions
        nil :require-match nil 'my-org-select-export-history
        default))))

  (defun my-org-export-get-function ()
    (alist-get
     (my-org-select-export-function)
     my-org-export-functions))

  (defun my-org-export-region-to-html (beg end export-fn)
    (interactive
     (list
      (region-beginning)
      (region-end)
      (my-org-export-get-function)))
    (unless (region-active-p)
      (user-error "No active region; aborting"))
    (let ((current-window (selected-window)))
      (unwind-protect
          (progn
            (narrow-to-region beg end)
            (funcall export-fn nil nil t t nil))
        (select-window current-window)
        (deactivate-mark)
        (widen))))

  (defun mg-org-get-number-headings-in-file (file)
    "Get the number of org headings for FILE."
    (let ((count 0)
  	(buffer (find-file-noselect file)))
      (with-current-buffer buffer
        (org-map-entries (lambda () (setq count (+ count 1))) nil 'file))
      count))

  (defun mg-org--shorten-file-path (path)
    "Replace user's home directory in PATH with ~"
    (let ((home (expand-file-name "~/")))
      (if (string-prefix-p home path)
          (concat "~" (substring path (1- (length home))))
        path)))

  (defun mg-org-capture-generate-flash-header ()
    "Generate the header to use in flaschards."
    (let ((link (mg-org--capture-get-last-file-link)))
      (format "%s @ %s" (mg-org--shorten-file-path
  		       (mg-org--capture-get-last-file-link))
  	      (format-time-string denote-id-format))))

  (defun mg-org-compile-tex-from-assets ()
    "Compile a tex file from pkm's assets, clean intermediary files and open the resulting PDF."
    (interactive)
    (let* ((default-directory mg-pkm-assets-directory)
  	 (file-name (read-file-name "Insert the tex file path: ")))
      (compile
       (format "%s && %s && %s && %s"
  	     (format "lualatex %s" file-name)
  	     (format "biber %s" (replace-regexp-in-string ".tex" "" file-name))
  	     (format "lualatex %s" file-name)
  	     "rm -f *.nav *.log *.bcf *.snm *.aux *.blg *.out *.toc *.bbl *.xml"))))

  (defun mg-org--capture-get-last-file-link ()
    "In `org-capture' context, get last visited file's name and format as link."
    (let ((link (format "[[file:%s]]" (plist-get org-capture-plist :original-file))))
      link))

  (provide 'mg-org)
  ;;; mg-org.el ends here
#+end_src

** The ~mg-bib.el~ library
:PROPERTIES:
:ID:       FBDD1B14-1B4E-4905-ABBB-DA9131AF0644
:END:

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-bib.el"
  ;;; mg-bib.el --- Extensions for bibliographic packages -*- lexical-binding: t -*-

  ;; Copyright (C) 2025  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.1.0
  ;; Package-Requires: ((emacs "29.4"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces some extensions that I use to manage
  ;; bibliography files. The idea of this whole library is to leverage
  ;; org-mode to organize my bibliography.

  ;;; Code:

  (require 'mg-org)
  (require 'mg-denote)

  (defun mg-bib-search-add-to-reading-list ()
    "Search for a bibliography entry in the minibuffer, and add it to `mg-reading-list-file'."
    (interactive)
    (when-let* ((key (citar-select-ref))
  	      (title (citar-get-value "title" key)))
      (save-excursion
        (with-current-buffer (find-file-noselect mg-reading-list-file)
    	(goto-char (point-max))
    	(beginning-of-line)
    	(insert (format "* TODO %s [cite:@%s]\n" title key))))))

  (defun mg-bib-count-references ()
    "Return the number of references in `mg-references-file'."
    (interactive)
    (let ((count
      	 (mg-org-get-number-headings-in-file mg-references-file)))
      (message "The bibliography org file contains %s entries" count)))

  (defun mg-bib-denote-org-capture-book-isbn-biblio ()
    "Custom `org-capture' template to add a book reference from a isbn code."
    (let ((isbn (mg-bib--denote-isbn-prompt)))
      (mg-bib-denote-org-capture-paper-biblio isbn)))

  (defun mg-bib-denote-org-capture-website-biblio ()
    "Custom `org-capture' template to add a website reference."
    (let* ((url (read-string "URL: "))
      	 (title (mg-bib--www-get-page-title url))
      	 (authors (mg-bib--denote-prompt-authors))
      	 (date (org-read-date nil nil nil "Insert the article date: " nil nil nil))
  	 (bibtex (format "@misc{%s,\nauthor = {%s},\ntitle = {%s},\nurl = {%s},\ndate = {%s},\nnote = {[Accessed %s]},\n}"
      			 "0000"
      			 authors
      			 title
      			 url
      			 date
      			 (format-time-string "%Y-%m-%d")))
  	 (bibtex-list (mg-bib--bibtex-parse-entry bibtex)))
      (setq bibtex-list (push (format "@misc{%s"
  				    (mg-bib--bibtex-generate-key bibtex-list))
  			    (cdr bibtex-list)))
      (when-let* ((title (mg-bib--bibtex-get-field-content bibtex-list "title"))
      		(heading (format "* %s\n" title)))
        (format "%s%s%s" heading
      	      (mg-bib--denote-bibtex-org-block
  	       (mg-bib--bibtex-list-to-string bibtex-list))
  	      "- Overview :: \n- Findings :: \n- Significance :: \n"))))

  (defun mg-bib-denote-org-capture-paper-biblio (&optional isbn)
    "Custom `org-capture' template to add a paper/book reference."
    (let ((bibtex-input
           (if isbn
               (mg-bib--bibtex-parse-entry
  	      (mg-bib--isbn-to-bibtex isbn))
             (mg-bib--bibtex-parse-entry
              (mg-bib--denote-bibtex-prompt)))))
      (when (not bibtex-input)
        (user-error "Couldn't retrieve the BibTeX entry."))
      (when-let*
  	((key (mg-bib--bibtex-generate-key bibtex-input))
  	 (bibtex-list (mg-bib--bibtex-refactor-entry-header bibtex-input key))
      	 (title (mg-bib--bibtex-get-field-content bibtex-list "title"))
      	 (heading (format "* %s\n" title))
  	 (file-path (mg-bib--denote-pull-resource-for-entry key)))
        (format "%s%s%s" heading
      	      (mg-bib--denote-bibtex-org-block
  	       (mg-bib--bibtex-list-to-string
  		(mg-bib--bibtex-append-field bibtex-list "file" (mg-bib--bibtex-format-file-for-field file-path)))
  	       file-path)
  	      "- Overview :: \n- Findings :: \n- Significance :: \n"))))

  (defun mg-bib--denote-identifier-from-attrs (file)
    "Get the creation date of FILE from its attributes.
    Returns the creation date timestamp, otherwise nil."
    (let ((file-attrs (file-attributes file)))
      (if file-attrs
          (let ((creation-time (nth 6 file-attrs)))
            (if creation-time
                (format-time-string denote-id-format creation-time)
    	    nil)))))

  (defun mg-bib--denote-remove-identifier-from-key (key)
    "Remove the identifier part from KEY, as its structure is timestamp_author_title_year."
    (let ((parsed-key (string-split key "_" t nil)))
      (string-join (delq (car parsed-key) parsed-key) "_")))

  (defun mg-bib--denote-pull-resource-for-entry (key)
    "Prompt the user for file path of paper having key KEY, format the
  file name and move it in the `denote-directory'.

  KEY has the form timestamp_author_title_year, therefore this
  function rules out the timestamp, which is not needed to create
  the unique filename, as it's inserted by `denote', and uses the
  author, title and year only to rename the resource file."
    (let* ((file-path (read-file-name "Select a PDF file: "))
      	 (file-exists (file-exists-p file-path))
      	 (is-pdf (string-match-p "\\.pdf$" file-path)))
      (cond
       ((not file-exists)
        (user-error "Error: File does not exist."))
       ((not is-pdf)
        (user-error "Error: Selected file is not a PDF.")))
      (setq key (mg-bib--denote-remove-identifier-from-key key))
      (let* ((keywords (denote-keywords-prompt))
        	   (identifier (mg-bib--denote-identifier-from-attrs file-path))
        	   (new-file-name (format "%s--%s__%s" identifier key
        				  (mapconcat #'identity 
        					     (delete-dups (copy-sequence keywords))
        					     "_")))
        	   (new-file-path (format "%s/assets/%s.pdf" (denote-directory) new-file-name)))
        (rename-file file-path new-file-path)
        new-file-path)))

  (defun mg-bib--bibtex-format-file-for-field (file-path)
    "Format FILE-PATH to be inserted as file field in the bibtex entry."
    (let ((file-name (car (last (split-string file-path "/")))))
      (format "%s:../pkm/assets/%s:application/pdf" file-name file-name)))

  (defun mg-bib--bibtex-generate-key (bibtex-list)
    "Generate a bibtex key for BIBTEX-LIST.
  The key format is timestamp-author-title-year."
    (let ((author (or (mg-bib--bibtex-get-author-for-key bibtex-list) "noauthor"))
  	(title (or (mg-bib--bibtex-get-title-for-key bibtex-list) ""))
  	(year (or (mg-bib--bibtex-get-year-for-key bibtex-list) "nodate"))
  	(timestamp (format-time-string denote-id-format)))
      (format "%s_%s_%s_%s" timestamp author title year)))

  (defun mg-bib--bibtex-get-author-for-key (bibtex-list)
    "Get the author from BIBTEX-LIST, formatted and ready to be used
  in the bibtex key."
    (let* ((first-author (string-trim
  			(car (string-split
  			      (downcase (mg-bib--bibtex-get-field-content bibtex-list "author")) "and"))))
  	 (author-tag
  	  (if (string-match "," first-author)
  	      (car (string-split first-author ","))
  	    (car (cdr (string-split first-author " "))))))
      ;; NOTE: In case there was no way of getting the surname, just
      ;; grab the whole author string.
      (if author-tag
  	(mg-bib--bibtex-sanitize-author-for-key author-tag)
        (mg-bib--bibtex-sanitize-author-for-key first-author))))

  (defun mg-bib--bibtex-sanitize-author-for-key (surname)
    "Perform a sanitization over the author's surname to generate
   the bibtex key."
    ;; This is required because sometimes we have "John Jr., Doe". Then,
    ;; producing "john jr." as surname for the key to be generated is
    ;; WRONG. Moreover, sometimes there are "-" signs in author keys,
    ;; e.g., Anthropic-AI. Therefore, remove those.
    (let ((sanitized-surname (car (split-string surname " "))))
      (replace-regexp-in-string "-" "" sanitized-surname)))

  (defun mg-bib--bibtex-get-year-for-key (bibtex-list)
    "Extract year from BIBTEX-LIST entry for use in BibTeX key.
  Looks first in the 'year' field, then in the 'date' field.
  Returns the first 4-digit year (between 1000-2999) found or signals an error."
    (let* ((year (mg-bib--bibtex-get-field-content bibtex-list "year"))
           (date (mg-bib--bibtex-get-field-content bibtex-list "date"))
           (year-regexp "\\b\\(1[0-9][0-9][0-9]\\|2[0-9][0-9][0-9]\\)\\b"))
      (cond
       ((and year
             (string-match year-regexp year))
        (match-string 1 year))
       ((and date
             (string-match year-regexp date))
        (match-string 1 date))
       (t
        (user-error "No valid year found in 'year' or 'date' fields")))))

  (defun mg-bib--bibtex-get-type (bibtex-list)
    "Get the entry type for BIBTEX-LIST."
    (let ((field (car bibtex-list)))
      (when (string-match "^@\\(\\w+\\){\\([^,]+\\)" field)
        (let ((type (downcase (match-string 1 field))))
  	type))))

  (defun mg-bib--bibtex-refactor-entry-header (bibtex-list key)
    "Refactor BIBTEX-LIST's header to be downcase and with custom
   KEY."
    (let ((type (mg-bib--bibtex-get-type bibtex-list)))
      (push (format "@%s{%s" type key) (cdr bibtex-list))))

  (defun mg-bib--bibtex-sanitize-title-for-key (title)
    "Sanitize TITLE string for use in a BibTeX citation key.
  Removes common punctuation marks and special characters."
    (let* ((chars-to-remove '(":" "/" "." "'" "-" "," "?" "!" ";" "&" "(" ")" "[" "]"))
           (case-fold-search nil)
           (sanitized title))
      (dolist (char chars-to-remove)
        (setq sanitized (replace-regexp-in-string (regexp-quote char) " " sanitized)))
      sanitized))

  (defconst mg-bib--title-keys-to-rule-out '("a" "the" "an" "for")
    "List of some title keys I'd prefer not to use.")

  (defun mg-bib--bibtex-get-title-for-key (bibtex-list)
    "Get the title from BIBTEX-LIST, formatted and ready to be used
  in the bibtex key."
    (when-let* ((title-early (mg-bib--bibtex-get-field-content bibtex-list "title"))
  	      ;; NOTE: Sometimes titles have `'`, `:`, etc. signs in
  	      ;; them. Let's rule those diacritics out.
  	      (title (mg-bib--bibtex-sanitize-title-for-key title-early))
  	      (first (downcase (car (split-string title " ")))))
      ;; NOTE: titles have articles, clauses, etc. I'd like to rule them
      ;; out and have more meaningful keys.
      (when (member first mg-bib--title-keys-to-rule-out)
        (setq first (downcase (car (cdr (split-string title " "))))))
      first))

  (defun mg-bib--denote-bibtex-prompt (&optional default-bibtex)
    "Ask the user for a bibtex entry. Returns the sanitised
            version. See `mg-bib--denote-sanitise-bibtex' for details."
    (let* ((def default-bibtex)
        	 (format (if (and def (not (string-empty-p def)))
        		     (format "Bibtex [%s]: " def)
        		   "Bibtex: "))
        	 (sanitised-bibtex (read-string format nil nil def)))
      (if sanitised-bibtex
        	sanitised-bibtex
        (user-error "Invalid BiBTeX entry provided to `mg-bib--denote-bibtex-prompt'"))))

  (defun mg-bib--denote-isbn-prompt ()
    "Ask the user for a isbn entry."
    (let ((isbn (read-string "ISBN: ")))
      isbn))

  (defun mg-bib--denote-bibtex-org-block (bibtex &optional file)
    "Returns a string representing an org `bibtex' source block
            encompassing BIBTEX, a string of a bibtex entry."
    (let* ((src
            (format "#+begin_src bibtex :tangle \"%s\"\n%s\n#+end_src" mg-bibliography-path bibtex))
  	 (keywords (mg-bib--denote-cycle-through-keywords))
           (entries (format
            	   ":PROPERTIES:\n:FILE: %s\n:NOTES:\n:KEYWORDS: %s\n:END:\n"
  		   (if file (mg-denote-generate-link-from-file-path file) "")
  		   (if keywords (mg-bib--denote-format-keywords-from-properties keywords) "")
  		   )))
      (format "%s\n%s\n" entries src)))

  (defun mg-bib--bibtex-early-sanitize (bibtex)
    "Perform some early initialization on BIBTEX."
    (replace-regexp-in-string "[ \t]+=" " =" (replace-regexp-in-string "\n[ \t]+" "\n" (replace-regexp-in-string "[ \t]+\n" "\n" bibtex))))

  (defun mg-bib--denote-prompt-authors ()
    "Get authors from user, possibly using autocomplete."
    (let ((entries (parsebib-parse mg-bibliography-path :fields (list "author")))
          authors)
      (maphash (lambda (key entry)
                 (let ((author (assoc "author" entry)))
  		 (when author
                     (push (string-split (cdr author) " and " t nil) authors))))
               entries)
      (if-let ((candidates
  	   (delq 'nil (mapcar (lambda (entry)
  				(when (string-match-p "," entry)
  				  (let ((parsed (string-split entry ", " t nil)))
  				    (format "%s %s" (car (cdr parsed)) (car parsed)))))
  			      (flatten-list authors)))))
  	(completing-read-multiple "Insert authors: " candidates)
        (user-error "Can't retrieve suggestions for authors"))))

  (defun mg-bib--bibtex-parse-entry (bibtex)
    "Parse BIBTEX to make a list.
  Each entry is a bibtex field with a value."
    (let* ((bibtex-fields
  	  (string-split (mg-bib--bibtex-early-sanitize bibtex) ",$"))
  	 (bibtex-list
  	  (mapcar (lambda (string)
  		    (string-trim (replace-regexp-in-string "\n" " " string)))
  		  bibtex-fields))
  	 (bibtex-final (reverse bibtex-list))
  	 (before-check (nreverse
  			(append (list (setcar bibtex-final (replace-regexp-in-string "}.*?}" "}" (car (last bibtex-list)))))
  				(cdr bibtex-final)))))
      (if (and before-check (string= "}" (car (last before-check))))
  	(butlast before-check)
        before-check)))

  (defun mg-bib--bibtex-get-field (bibtex-list field)
    (seq-find (lambda (string)
  	      (string-match-p (format "%s.*?=" field) string)) bibtex-list))

  (defun mg-bib--bibtex-get-field-content (bibtex-list field)
    "Get the content for FIELD in parsed BibTeX entry BIBTEX-LIST.

  This function rules out all { and } signs from the field and gets
  the string after the equal sign. This is the less convoluted way
  of correctly parsing a BibTeX field's content."
    (when-let ((raw-field (mg-bib--bibtex-get-field bibtex-list field)))
      (setq raw-field (replace-regexp-in-string "{" "" raw-field))
      (setq raw-field (replace-regexp-in-string "}" "" raw-field))
      (when (string-match (format "%s\\s-*=[[:space:]]*\\([^}]*\\)" field) raw-field)
        (match-string 1 raw-field))))

  (defun mg-bib--bibtex-list-to-string (bibtex-list)
    "Reformat BIBTEX-LIST as a bibtex entry (string)."
    (let ((closed-list
  	 (mg-bib--bibtex-close-entry bibtex-list)))
      (mapconcat #'identity closed-list ",\n")))

  (defun mg-bib--bibtex-close-entry (bibtex-list)
    "Close the bibtex entry represented by BIBTEX-LIST."
    (nreverse
       (append (list "}") (nreverse bibtex-list))))

  (defun mg-bib--bibtex-append-field (bibtex-list field value)
    "Append FIELD with value VALUE to BIBTEX-LIST."
    (let ((field-formatted (format "%s = {%s}" field value)))
      (add-to-list 'bibtex-list field-formatted :append nil)))

  (defun mg-bib--bibtex-list-find-field-and-replace (bibtex-list field replace)
    "Find and replace a specific field in a BibTeX entry list."
    (mapcar (lambda (entry)
              (if (string-match (format "%s.*?=" field) entry)
                  (replace-regexp-in-string 
                   (format "%s.*?= {[^}]*}" field)
                   (format "%s = {%s}" field replace)
                   entry)
                entry))
            bibtex-list))

  (defun mg-bib--denote-cycle-through-keywords ()
    "Cycle through keywords in the references file prompting the user for an input."
    (let* ((keywords 
  	  (delete-dups (flatten-list (mapcar (lambda (entry) (string-split (cdr entry) ";" t nil))
  					     (mg-bib--get-keywords-from-file mg-references-file)))))
  	 (selected-keywords (completing-read-multiple "Select keywords: " keywords)))
      (sort selected-keywords #'string<)))

  (defun mg-bib--field-empty-p (entry)
    "Return t if ENTRY contains only empty braces (i.e. '{}'), nil otherwise.
  ENTRY should be a string containing a BibTeX field value."
    (string-match-p "^[[:space:]]*{[[:space:]]*}[[:space:]]*$" entry))

  (defun mg-bib--bibtex-from-isbn-sanitize (bibtex)
    "Sanitize BIBTEX, assuming that it has been generated by a ISBN."
    (when (mg-bib--field-empty-p bibtex)
      (kill-new bibtex)
      (user-error "The BibTeX entry is malformed, it has been copied to the killring.")))

  (defun mg-bib--isbn-to-bibtex (isbn)
    "Given ISBN for a book, generate a BibTeX entry.
  This code is adapted from the one developed by John Kitchin for org-ref."
    (let* ((url (format "https://openlibrary.org/isbn/%s.json" isbn))
           (json (with-current-buffer (url-retrieve-synchronously url)
                   (json-read-from-string (string-trim (buffer-substring url-http-end-of-headers (point-max))))))
  	 (title (cdr (assoc 'title json)))
  	 (publishers-list (cdr (assoc 'publishers json)))
  	 (publisher (mapconcat #'identity publishers-list ", "))
  	 (date (cdr (assoc 'publish_date json)))
  	 (author-urls (cdr (assoc 'authors json)))
  	 (authors (mapconcat
  		   #'identity
  		   (cl-loop for aurl across author-urls
  			    collect
  			    (with-current-buffer (url-retrieve-synchronously
  						  (format "https://openlibrary.org%s.json"
  							  (cdr (assoc 'key aurl))))
  			      (cdr (assoc 'personal_name
  					  (json-read-from-string
  					   (string-trim (buffer-substring url-http-end-of-headers (point-max))))))))
  		   " and "))
  	 (burl (format "https://openlibrary.org/%s" (cdr (assoc 'key json))))
  	 (bibtex (format "@book{,
    author = {%s},
    title = {%s},
    publisher = {%s},
    date = {%s},
    url = {%s}
  }"
  			 authors
  			 title
  			 publisher
  			 date
  			 burl)))
      bibtex))

  (defun mg-bib-kill-bibtex-from-isbn ()
    "Prompt a ISBN interactively and kill the generated BibTeX entry."
    (interactive)
    (when-let ((bibtex (mg-bib--isbn-to-bibtex
  		      (mg-bib--denote-isbn-prompt))))
      (kill-new bibtex)))

  (defun mg-bib--www-get-page-title (url)
    "Get the page title from URL."
    (let ((title))
      (with-current-buffer (url-retrieve-synchronously url)
        (goto-char (point-min))
        (re-search-forward "<title>\\([^<]*\\)</title>" nil t 1)
        (setq title (match-string 1)))
      title))

  (defun mg-bib--denote-prompt-and-return-point ()
    "Prompt the user for org headings in `mg-references-file' and return the point related to the notes part of the selected heading."
    (save-excursion
      (with-current-buffer (find-file-noselect mg-references-file)
        (let* ((current-pos (point))
  	     (headings (org-map-entries
  			(lambda ()
  			  (cons (org-get-heading t t t t)
  				(point)))
  			t 'file))
  	     (headings-names (mapcar #'car headings))
  	     (selected (completing-read "Select heading: " headings-names nil t))
  	     (heading-pos (cdr (assoc selected headings))))
  	(if (not heading-pos)
  	    (error "Heading not found")
  	  (goto-char heading-pos)
  	  (let ((end-of-subtree (save-excursion
  				  (org-end-of-subtree t t))))
              (if (re-search-forward "^[ \t]*#\\+end_src" end-of-subtree t)
  		(progn
                    (end-of-line)
                    (let ((target-pos (point)))
  		    target-pos))
  	      (error "No source block found in the selected heading"))))))))

  (defun mg-bib-denote-goto-notes-interactively ()
    "Prompt the user for headings in `mg-references-file' and go to the notes section of the selected heading. The subtree is then narrowed for convenience."
    (interactive)
    (let ((point (mg-bib--denote-prompt-and-return-point)))
      (with-current-buffer (find-file mg-references-file)
        (goto-char point)
        (org-reveal)
        (org-narrow-to-subtree))))

  (defun mg-bib--get-keywords-from-file (file-path)
    "Return a list with all keywords in the KEYWORDS field of the
   properties drawer found in FILE-PATH.

  Tags are returned as a single string, where each tag is separated
   by a ';' sign from the other tag."
      (with-current-buffer (find-file-noselect file-path)
        (org-element-map (org-element-parse-buffer) 'headline
  	(lambda (headline)
            (save-excursion
              (goto-char (org-element-property :begin headline))
              (let ((keywords (org-entry-get (point) "KEYWORDS")))
                (when keywords
  		(cons (org-element-property :raw-value headline)
                        keywords))))))))

  (defun mg-bib--denote-format-keywords-from-properties (keywords)
    "Format KEYWORDS to be ready to be inserted in the properties
   drawer."
    (string-join (mapcar (lambda (keyword)
  			 (replace-regexp-in-string " " "_" (downcase keyword)))
  		       keywords) ";"))

  (provide 'mg-bib)
  ;;; mg-bib.el ends here
#+end_src

** The ~mg-notmuch.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-notmuch.el"
  ;;; mg-notmuch.el --- Custom functions for `notmuch' -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.com/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.4"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces a series of custom function I use for the
  ;; `notmuch' e-mail client for Emacs.

  ;;; Code:

  (defconst mg-notmuch--get-emails "mbsync -a"
    "Shell command used to get new emails.")

  (defconst mg-notmuch--reindex "notmuch new"
    "Shell command used to reindex notmuch.")

  (defconst mg-notmuch--update-shell-commands
    (list mg-notmuch--get-emails mg-notmuch--reindex
  	"Shell commands used to update the mail directory.
  NOTE: The order of these commands *matter*. Do not change it."))

  (defun mg-notmuch-update-mail ()
    "Update the mail directory."
    (interactive)
    (dolist (cmd mg-notmuch--update-shell-commands)
      (call-process-shell-command cmd nil 0)))

  (provide 'mg-notmuch)

  ;;; mg-notmuch.el ends here
#+end_src

** The ~mg-pkm-utils.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-pkm-utils.el"
  ;;; mg-pkm-utils.el --- Utility functions for my pkm -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.4"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces several utility functions and commands to
  ;; manage my "Personal Knowledge Management System". Although the
  ;; system heavily relies on `org-mode' and `denote', functions in this
  ;; library tackle general purpose use-cases (i.e., not necessarily
  ;; related to `org-mode' or `denote').

  ;;; Code:

  (require 'mg-org)

  (defun mg-org-compute-deep-work-minutes (start-date end-date)
    "Compute the minutes of deep work from START-DATE to END-DATE.

    This function searches into both projects and archive files to
    retrive logbooks properties and their related timing."
    (interactive
     (list
      (format "<%s>" (org-read-date))
      (format "<%s>" (org-read-date))))
    (let* ((default-directory (denote-directory))
  	 (target-files
  	  '(mg-work-projects-file
  	    mg-archive-file)))
      (insert (format "%s"
  		    (apply '+ (mapcar (lambda (file)
  					(mg-org-get-clock-minutes file start-date end-date)) target-files))))))

  (defun mg-toggle-pdf-presentation-mode ()
    "Toggle a presentation mode to show PDFs in a clean layout.

  When showing a PDF in docview, the modeline should be hidden, and the document itself should be centered, for better visibility."
    (interactive)
    (toggle-frame-fullscreen)
    (if (not (bound-and-true-p hide-mode-line-mode))
        (hide-mode-line-mode 1)
      (hide-mode-line-mode 0))
    (pdf-view-fit-page-to-window))

  (provide 'mg-pkm-utils)
  ;;; mg-pkm-utils.el ends here
#+end_src

** The ~mg-denote.el~ library
:PROPERTIES:
:ID:       cf17aa34-cd6c-4eea-be80-c111b00f5f3e
:END:

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-denote.el"
  ;;; mg-denote.el --- Custom code to extend denote -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.3
  ;; Package-Requires: ((emacs "29.3"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces some custom Emacs Lisp code to extend the
  ;; functionalities provided by `denote'. Along with `org', `denote' is
  ;; probably one of the packages that I use (and tweak) the most within
  ;; Emacs.

  ;;; Code:

  (defun mg-denote-copy-timestamp-to-killring ()
    "Helper function to get a convenient denote-style timestamp."
    (interactive)
    (kill-new (format-time-string denote-id-format)))

  (defun mg-denote--get-item (filter-regex)
    "Get a file path interactively starting from the denote-directory."
    (let* ((candidates (denote-directory-files filter-regex))
  	 (file-name (completing-read
  		     "Choose FILE: "
  		     candidates))
  	 (file-path file-name))
      file-path))

  (defun mg-denote--get-file ()
    "Get a denote file interactively starting from the denote-directory"
    (mg-denote--get-item denote-id-regexp))

  (defun mg-denote-find-file ()
    "Find files interactively starting from the denote-directory."
    (interactive)
    (find-file (mg-denote--get-file)))

  (defun mg-denote--get-zettel ()
    "Get zettel interactively starting from the denote directory."
    (mg-denote--get-item denote-signature-regexp))

  (defun mg-denote-find-zettel ()
    "Find zettels interactively starting from the denote-directory."
    (interactive)
    (find-file (mg-denote--get-zettel)))

  (defun mg-insert-denote-or-normal-link (name)
    "Insert a denote link if the file specified by buffer-name is a denote item, otherwise a normal link."
    (if (denote-file-is-note-p (format "%s" name))
        (mg-denote--insert-link-from-file-path name)
      (format "[[file:%s]]" name)))

  (defun mg-denote--insert-link-from-file-path (file-path)
    "Insert a denote link provided FILE-PATH."
    (let ((file-description (denote--link-get-description file-path)))
      (denote-link file-path (denote-filetype-heuristics file-path) file-description)))

  (defun mg-denote-generate-link-from-file-path (file-path)
    "Generate a denote link provided FILE-PATH."
    (let ((file-description (denote--link-get-description file-path)))
      (denote-format-link file-path file-description (denote-filetype-heuristics file-path) nil)))

  (defun mg-denote-insert-zettel-link ()
    "Select a zettel from `denote-directory` and insert its link at current point."
    (interactive)
    (let ((file-path
  	 (mg-denote--get-zettel)))
      (mg-denote--insert-link-from-file-path file-path)))

  (defun mg-denote-grep-on-zettels ()
    "Grep for a search query, but only on zettels."
    (interactive)
    (let ((zettels
  	 (denote-directory-files denote-signature-regexp)))
      (consult-grep zettels)))

  (defun mg-denote--rename-file-helper (file-path)
    "Rename FILE-PATH using `denote-rename-file' in a temporary `dired' buffer.
  The buffer is not shown to the user and is killed after the operation."
    (let ((temp-buffer (generate-new-buffer "*temp-dired*")))
      (with-current-buffer temp-buffer
        (dired (file-name-directory file-path))
        (dired-goto-file file-path)
        (call-interactively #'denote-rename-file)
        (kill-buffer))))

  (defun mg-denote-copy-to-assets-and-rename ()
    "Copy the current `dired' entry to the assets folder and rename it.
  The renaming convention is the `denote' one."
    (interactive)
    (if (derived-mode-p 'dired-mode)
      (let* ((file-path (dired-get-filename))
  	   (file-name (car (last (string-split file-path "/" nil nil))))
  	   (new-path (expand-file-name file-name mg-pkm-assets-directory)))
        (copy-file file-path new-path)
        (mg-denote--rename-file-helper new-path)))
      (user-error "Not in a dired buffer."))

  (defun mg-denote-get-index-in-dired ()
    "Get the zettels index in a `dired' buffer.
  The zettels index is the entry point of networked notes - i.e.,
  all notes with a depth of 1 in their signature."
    (interactive)
    (denote-sequence-dired nil 1))

  (provide 'mg-denote)
  ;;; mg-denote.el ends here
#+end_src

** The ~mg-kernel.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-kernel.el"
  ;;; mg-kernel.el --- Utilities to use with the Linux kernel -*- lexical-binding: t -*-

  ;; Copyright (C) 2025  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.com/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.4"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This is a series of utility functions I use when working with the
  ;; Linux kernel. All of my activities lie into Emacs, and I really
  ;; enjoy writing Emacs Lisp code. Therefore, some of these function
  ;; could also be easily implemented as simple bash scripts. Writing
  ;; them in Lisp is merely a convenience for me working with Emacs
  ;; every day.

  ;;; Code:

  ;; First part of this library has been taken from . I found many of
  ;; these defaults useful when it comes to kernel development.

  (defconst kernel-column-limit 80
    "It is only 80, get over it.")

  (defvar kernel-source-path "~/sources/linux"
    "The kernel source path.")

  (defvar kernel-comment-style 'extra-lines
    "Default style is 'extra-lines.
  The another option is 'extra-bottom-line")
  (make-variable-buffer-local 'kernel-comment-style)

  (defvar kernel-lineup-tabs-only nil
    "If it is non-nil the kernel lineup indentation will make use of tabs only.
  When nil lineup indentation will use TABS  SPACES.")
  (make-variable-buffer-local 'kernel-lineup-tabs-only)

  (defvar kernel-lineup-maximum-tabs nil
    "If it is non-nil its value will be the maximum tabs steps in kernel lineup
  indentation.
  When nil there will not be such a limit.
  In both cases there is also the maximum limit forced by the
  `kernel-lineup-arglist' function in conjuction with the
  `kernel-column-limit' constant.")
  (make-variable-buffer-local 'kernel-lineup-maximum-tabs)

  (defun setup-kernel-style (comment-style lineup-tabs-only lineup-maximum-tabs)
    (setq kernel-comment-style comment-style)
    (setq kernel-lineup-tabs-only lineup-tabs-only)
    (setq kernel-lineup-maximum-tabs lineup-maximum-tabs))

  (defun kernel-comment-dwim ()
    "Comments or uncomments the region.
  If there's no active region adds/indents an one line comment or
  comments/uncomments the current line if the one line comment is
  empty."
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (progn
            (setq beg (region-beginning)
                  end (region-end))
            (if (comment-only-p beg end)
                (uncomment-region beg end)
              (progn
                (comment-region beg end)
                (save-excursion
                  (goto-char beg)
                  ;; Remove extra top line
                  (when (equal kernel-comment-style 'extra-bottom-line)
                    (re-search-forward "/\\*\\s-*\n\\s-*\\(\\*\\)" end t)
                    (replace-match "/\\1"))
                  ;; Update end point
                  (goto-char beg)
                  (re-search-forward "\\*/" nil t)
                  (setq end (point))
                  ;; This error is fixed in version 25.
                  (when (< emacs-major-version 25)
                    (tabify beg end))
                  ;; Cleaning only trailing spaces inserted by comment-region.
                  ;; Existing ones are not touched.
                  (goto-char beg)
                  (while (re-search-forward
                          "\\(/\\|^\\s-\\)\\(\\*\\)\\(\\s-$\\)" end t nil)
                    (replace-match "\\1\\2")
                    (save-excursion
                      (re-search-forward "\\*/" nil t 1)
                      (setq end (point))))))))
        (progn
          (setq beg (line-beginning-position)
                end (line-end-position))
          (if (save-excursion
                (goto-char beg)
                (looking-at "\\s-*$"))
              (progn
                (comment-indent)
                (indent-according-to-mode))
            (if (comment-only-p beg end)
                (uncomment-region beg end)
              (if (save-excursion
                    (goto-char beg)
                    (re-search-forward "/\\*\\s-\\*/" end t 1))
                  (progn
                    (save-excursion
                      (goto-char beg)
                      (let (kill-ring)
                        (comment-kill nil)))
                    ;; Read end position directly
                    (comment-region beg (line-end-position)))
                (comment-indent))))))))

  (defun kernel-align-to-equals (begin end)
    "Align region to equal signs."
    (interactive "r")
    (align-regexp begin end "\\(\\s-*\\)=" 1 1 nil))

  (defun kernel-lineup-arglist (langelem)
    "Line up the argument list for C function calls."
    (let* ((ret (c-lineup-arglist langelem))
           (anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (newcol (c-langelem-col langelem t))
           (steps (floor offset c-basic-offset)))
      (if (not kernel-lineup-tabs-only)
          ret
        (progn
          (when (>= ( newcol (* c-basic-offset steps))
                    kernel-column-limit)
            (setq steps (1- steps)))
          (when kernel-lineup-maximum-tabs
            (setq steps (min steps
                             kernel-lineup-maximum-tabs)))
          (* (max steps 1) c-basic-offset)))))

  (add-hook 'c-mode-common-hook
            (lambda ()
              (c-add-style
               "linux-kernel"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           kernel-lineup-arglist))
  	       (c-cleanup-list brace-else-brace
  			       brace-elseif-brace)))))
  (defun kernel-style-hook ()
    (let ((filename (buffer-file-name))
          (source-path (expand-file-name kernel-source-path)))
      ;; Enable kernel mode for the appropriate files
      (when (and filename
                 (string-match source-path filename))
        ;; Setup style
        (c-set-style "linux-kernel")
        (setq tab-width 8
              comment-style 'extra-line
              indent-tabs-mode t
              backward-delete-char-untabify-method nil)
        (c-toggle-auto-newline t)

        ;; Setup tree paths here
        (when (or (string-match (concat source-path "/net") filename)
                  (string-match (concat source-path "/drivers/net") filename))
          (setup-kernel-style 'extra-bottom-line t nil))
        (when (string-match (concat source-path "/drivers/usb/host") filename)
          (setup-kernel-style 'extra-lines t 2))

        ;; Set kernel style key bindings
        (local-set-key [remap comment-dwim] 'kernel-comment-dwim)
        (local-set-key (kbd "C-c a =") 'kernel-align-to-equals)
        ;; Setup white space highlighting
        (require 'whitespace)
        (setq whitespace-line-column kernel-column-limit
              whitespace-style '(face empty
                                      indentation::tab
                                      whitespace-space-before-tab
                                      space-before-tab::tab
                                      lines-tail
                                      trailing))
        (dolist (face '(whitespace-line
                        whitespace-indentation
                        whitespace-space
                        whitespace-space-before-tab
                        whitespace-empty
                        whitespace-trailing))
          (set-face-background face "red"))
        (set-face-attribute whitespace-line nil
                            :background "red"
                            :foreground "yellow"
                            :weight 'bold)
        (whitespace-mode t))))

  (add-hook 'c-mode-hook 'kernel-style-hook)

  ;; Then, the following code is brought by myself. Custom stuff I use
  ;; all the time.

  (defun mg-kernel--get-source-directory ()
    "Get the kernel source based on the current file."
    (if-let* ((file-name (buffer-file-name))
  	    (root (vc-git-root file-name)))
        root
      (car (find-file-read-args "Select KERNEL SOURCE: " nil))))

  (defun mg-kernel--do-grep (regexp)
    "Wrapper for `grep' to find definitions/usage of code
   snippets/structs in the kernel."
    (if-let ((kernel-directory (mg-kernel--get-source-directory)))
        (let ((default-directory kernel-directory))
  	(let* ((candidates
  		(split-string
  		 (shell-command-to-string
  		  (format "find $1 -name '*.[ch]' | xargs grep -EnH \"%s\"" regexp))
  		 "\n" t nil))
  	       (parsed (split-string
  			(completing-read "Select OCCUR to visit: " candidates)
  			":" t nil)))
  	  (with-current-buffer (find-file (expand-file-name (nth 0 parsed)))
  	    (goto-line (string-to-number (nth 1 parsed))))))
      (user-error "Something went wrong when selecting KERNEL SOURCE")))

  (defun mg-kernel--infer-regexp-to-search ()
    "Infer the regexp to search based on `point'.
  When we search for usage of a certain C expression inside the
  kernel source we do it because we are interested in what it's
  under our cursor. Therefore, use the current symbol as a prompt
  suggestion."
    (let* ((suggestion (symbol-at-point))
  	 (prompt (if suggestion
  		     (format "Provide a REGEXP to search [%s]: " suggestion)
  		   "Provide a REGEXP to search: ")))
      (read-string prompt nil nil suggestion nil)))

  (defun mg-kernel-do-grep ()
    "Prompt a regexp to grep in the kernel source."
    (interactive)
    (let ((regexp
  	 (mg-kernel--infer-regexp-to-search)))
      (mg-kernel--do-grep regexp)))

  (defun mg-get-kernel-version-from-source (source)
    "Return the kernel version from the source SOURCE.

  When interactive, prompt the user for a kernel source. NOTE: This
  function has a double check at the end, to be relatively sure
  that a proper kernel version is returned to the user. This makes
  sense because sometimes for a, e.g., mispell, the user provides a
  wrong directory as SOURCE. The check could've been performed
  better, but for now it just proved to work."
    (interactive
     (list
      (mg-kernel--get-source-directory)))
    (let* ((command (format "cd %s && make kernelversion" source))
  	 (kernel-version
  	  (shell-command-to-string command)))
      (if (string-match-p "\\<[0-9]+\\." kernel-version)
  	(message "Kernel version for specificed SOURCE is %s" (string-trim kernel-version))
        (user-error "Can't identify a kernel version for the specified SOURCE %s" source))))

  ;;; mg-kernel.el ends here
#+end_src
** The ~mg-personal.el~ library

#+begin_src emacs-lisp :tangle "mg-custom-modules/mg-personal.el"
  ;;; mg-personal.el --- Personal environment customization -*- lexical-binding: t -*-

  ;; Copyright (C) 2024  Claudio Migliorelli

  ;; Author: Claudio Migliorelli <claudio.migliorelli@mail.polimi.it>
  ;; URL: https://crawlingaway.org/emacs/dot-emacs
  ;; Version: 0.0.1
  ;; Package-Requires: ((emacs "29.1"))

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Commentary:
  ;; This library introduces some personal information I use to then
  ;; build documents, files, and knowledge-base related artifacts,
  ;; dynamically. Some of these utilities are related to my research
  ;; work.

  ;;; Code:

  (defconst mg-personal-research-start-year 2023
    "A variable used to record the year I began conducting research.")

  (defun mg-personal--get-raw-keywords-from-metanote ()
    "Get research areas I worked on from `mg-research-file'."
    (let ((research-areas '()))
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^\\* Active research projects" nil t)
          (org-map-entries
           (lambda ()
             (let ((areas (org-entry-get (point) "RESEARCH_AREAS")))
               (when areas
                 (push areas research-areas))))
           nil
           'tree))
        (nreverse research-areas))))

  (defun mg-personal-get-research-areas ()
    "Get research areas I worked on, as a list of strings, based on produced artifacts."
    (let* ((raw-keywords
    	  (mg-personal--get-raw-keywords-from-metanote))
    	 (formatted-keywords (delete-dups
    			      (flatten-list
    			       (mapcar
    				(lambda (keywords)
    				  (let ((formatted-keywords
    					 (replace-regexp-in-string "_" " " keywords)))
    				    (string-split formatted-keywords ";" t nil)))
    				raw-keywords)))))
      (sort (mapcar (lambda (keyword)
    		    (capitalize keyword))
    		  formatted-keywords)
    	  #'string<)))

  (provide 'mg-personal)
  ;;; mg-personal.el ends here
#+end_src
